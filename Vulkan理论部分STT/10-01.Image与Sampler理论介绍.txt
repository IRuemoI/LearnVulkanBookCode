10-01.Vulkan-Image与Sampler理论介绍

各位同学大家好，我们这节课开始了解图片与采样啊，也就是说我们接下来要开始进入这样一个贴图开合的过程了。
那么，我们首先了解一下zev OK里面的image啊，这个东西怎么去做？
在毛孔当中image，它是一个概念啊，代表着一个图像，它呢，可以是读入的纹理贴图，也可以是被渲染好的一张图片。
也就是说，它可以作为一个attachment被加到render pass里面啊，好，那么我们看一下啊，在lock里面一个image的构成，首先呢，是一个vk image哎，在这里呢，我们是不是可以回忆一下我们在做buffer的时候是不是也有一个vk buffer？
对吧，那wiki buffer呢？
跟wiki image它都是在CPU端，它存在的一种聚变功，只不过wiki buffer是一个纯粹纯粹的啊，一个内存性。
vk image呢是一个图片句柄，那么接下来呢，它就要有一个实在的显示空间，叫做vk device memory，那我们看啊，这个地方的vk device memory是不是跟我们vk buffer那个地方用的memory是一样的呀？
OK，那么接下来呢，就存在一个vk image v啊，这个是这个图片呃，对外的访问控制器，那么如果说啊，它被设置成了color的这样一个space pec，那么我们访问起来就是按照颜色的方式去访问。
如果它被设置成了depth aspect，那么这张图片在访问的时候就被变成了这样一个深度啊，深度图的这么一个访问方式，所以说呢，这三者共同构成了表空间控制器啊，这三种东西。
好，我们看一下啊，创建一个纹理贴图是一个怎样的过程？
我们先大概了解，首先呢，我们读入一张图片，这个地方呢，我们用的啊，沿用了之前课程的这么一个库啊sdb image。
那么最后呢，我们就创建一个vk image句柄啊，这个也很简单。
然后呢，我们创建一个sting buffer对吧？
因为我们这张图片呢，是用来背f来采样的呃，所以说呢，我们在客户端啊，就是在CPU是不会去读取这张图片的。
那么，这张图片的内存，它的property应该至少会是一个什么呀？
是一个device local bit对吧？
就是只是可读CPU跟不可读的，这样的话呢，它的内存就会被分配在线端就很快了。
OK，所以我们需要有一个station打法儿来，中间跳板一下，我再把图片复制过去，好那么当图片先拷贝到station上面，接下来我们去创建一个Vicky device memory。
这个的话呢，就是真实的啊，用来存放图片数据的地方诶，我们将二者进行绑定，对吧？
跟那个buffer band是一样的是吧？
然后呢，我们将staging上面的数据拷贝到这个里面啊device Mary，最后呢，我们用Vicky max创建一个Vicky match view，哎，我们看这个铁三角创建成功了，对吧？
OK，那么再接下来呢，就是去采样了啊，那么对于这节课来讲，其实device memory和vk image view我们之前都已经接触过了，对吧？
那么我们是不是只要专注看一看vk image啊，它里面的参数到底什么就可以了？
好，那么我们看一下。
它这里面的参数首先是一个vicky format，这个format呢是一张图片的格式信息，什么理解呢？
就是说对于这张图片的一个像素来讲啊，它里面到底包含哪些信息？
每个信息占有的位数如何？
比如说rdb各占32位。
也还是说这个像素啊，它是rc BA的，然后各加32位呢，这个意思？
然后呢，是viki mes type，那么它是一张图片的类型信息，比如说你是2d的还是3d的？
2d的呢，就是一张普通的图片，3d的话呢，你可能是一张q的啊，一堆图片的图片集对吧，然后有z坐标啊，所所以另外一张图片。
然后它有自己的长宽啊，这个非常简单every layers啊，这张图片包含多少layer？
也就是说啊，一张图对象包含多少张真正的图片？
比如说我虽然是一个Vicky image，但是我呢，其实这个image呀，它的背后对应着可以读入六张图片，那么这六张图片呢，就可以呃，全部都放到这个。
一个内存里，然后呢，通过array layers来规定说array layers=6，那么我就可以访问到六张了啊，我的三抛栏儿也可以采样六张图片了，那么它很适合去做pimple map，就是天空壳。
那么，接下来的话就是usage啊，这张图片的用途，那比如说你这张图片是color attachment还是depth attachment对吧？
你给到了letter pass。
sample采样数呃，我们在抗锯齿的时候用到这个参数，也就是说呃，我去呃，采样这张图片的话，我去显示它啊，那么我一次采样，你一个点还是说我采样四个点做平均啊等等？
接下来有一个参数叫tiling，这个tiling呢？
我们主要是区分于layout的区别啊，我们先看一看tiling分为linear和optimal linear就是线性的tiling呃，那么这个tiling呢？
它是说呀，你这个呃图片。
在内存当中啊，是如何排列的？
比如说你是线性的，那么就属于我们CPU跟可读的类型了，那么一行一行的排列是吧？
一行的排列怎么理解啊？
那么从你这个呃内存八分儿的开头是零零零一零二零三零四零五对吧？
然后呢，接下来换一行啊，一一二呃一零一一一二一三一四一五，然后之后是二零二一二三四，对吧？
这样排下去啊，就是先排列再排行。
但是呢，在后处理当中就很麻烦啊，因为我们经常会有一些算法啊，它需要说知道这个像素，它相邻的像素，比如说相邻的九宫格，对吧？
它的像素值是多少？
那么我们就需要干嘛呀？
跨行读取在这个地方呢，为什么跨行读取它的消耗非常高呢？
是因为呃gpu当中会有一个get始缓存的概念，对吧？
一级开始，二级开始等等啊，那么它呢？
其实读取这张图片的数据的时候，它并不是说把整张图片都读进来。
而你需要采样到，比如说呢，它图片中的某位置的时候，它会把这一个区域啊，它会把这个区域的整个像素的所有的这个所有的像素数据啊都读进来，那么读到它的cash里面，那如果说你是零点的话，那么就是按一行一行的改变，那么我只能读到，对吧？
它那个左右相邻的。
这么一堆数据读进来，那如果说你换一种方法，用optimal啊optimal的方式，那么我的排列就并不是说按照一行一行，可能按照相邻像素组组成一个块儿，相邻像素组成一个块儿，这样的方式去做不能存储。
那么我一口气读读进来的话呢，就是相邻像素的这个区域，对吧？
这些像素这个意思，所以说呢，它令分为linear optimal啊，我们经常会使用optimal。
layout那么layout呢？
可以理解为存储格式啊，那我们看一下经过format，我们可以知道像素它里面的排布对吧，如果它有零，我们可以得到整个像素。
啊，不像排污，你是横着排还是说按照区域排那么最后一步的话，就是如何把它放到内存当中啊，那么排完之后这些虚拟的概念，我们就该真正的落实到存储了。
那么layout对吧？
使用硬件的机理的无损压缩，它使得传输带喷压低啊，那么这种压缩类型就可以理解为layout，那具体怎么压的啊？
这个就是各家厂商实现不一样了。
okay，那么接下来我们来看一看sampler。
那么我们现在可以成功的读出一张vk image，对吧？
我们将它与sampler啊把一起扔到这个，我们的这个descriptor set里面，然后传到sheet r，那么sampler呢？
它就是用来按照纹理坐标uv对这张图片进行采样的，这么一个东西。
有对象那么所谓采样是什么意思呢？
每个顶点坐标都会有uv坐标设零到一对吧？
那么通过差值呢就可以得到当前fragment的uv坐标。
啊，那假设图片的宽高为wh，那么我们得到了uv，我们该去采样这张图片的哪个像素呢？
那么就是这样了。
image x代表说，我要采样的啊，在它那个点的坐标x。
那么，就用u坐标乘以我们乘以它的w那么image y，就用v乘以它的h我们就得到了一个image x和image y这么一个数啊，那这个坐标对就是我们应该取得的这个图片上的像素的作用。
啊，那么我们用这个像素值来着色这个fragment就可以了，那么这个过程呢？
就成为了。
当然，采样的算法多种多样啊，这种是最简单的，就是非过滤采样no fings啊这种方式，但这种方式呢，也会存在问题，我们看一下。
如果单纯的非规律采样啊，当图片的像素数量小于最终输出fragment的数量的时候，都会导致过怎样就是采样频率高出了信号频率什么意思呢？
我们看看这张图啊，对吧？
那么这张图假设它非常的小。
呃，但是呢，我的屏幕非常的大，或者说我输出的fragment非常的多，多到什么地步呢？
呃，多到说相邻的两个fragment或者相邻的n个fragment，它们都会采样到这张图片的同一个像素上了。
你张长宽实在太小，那么我们乘以一个uv值得到了一个值再去整，哎，发现好多uv值啊，虽然说不同，但是它经过计算之后得到最后那个采样的整数的坐标值都是一样的。
你看我们就变对吧，因为你这张图片太小了啊，那么我们怎么办呢啊？
我们就可以用byline ing啊linear linear的一个feel free啊，就先计算一个像素的，然后呢，剩余的小数部分呢啊，它偏向哪一些格格？
我们就呢，将其临近的，比如四个像素啊，进行一个加权平均全值呢，就是我真正的这个点，那么距离你这四个像素之间的距离啊，距离对吧，可以做一个加权，那么最终得到一个输出的fragment的颜色值。
诶，都是这样了，它都会变模糊，对吧？
但是呢，虽然模糊看上去呢，还是挺不懂。
okay，那么这个就是双线性采样啊，把它临近的四个像素做一次加权平均。
好那么一般情况下呢？
我们采用bilinear的啊，但是也会造成一定的问题什么如果说啊，做一个正方形正对着我们，那么以上的采样都没问题啊，但是如果我们从一个斜视的角度去观察bilinear，就会出现远方采样过于模糊，就比如这张图片是吧？
我们看啊，近处没有啥问题啊，在远处是不是模模糊糊的一整片啊？
那为什么呢啊？
我们看啊，在我们渲染的fragment里面，那么这一堆是不是我们看这一张图片，是不是都是我们渲染出来的一堆fragment呀？
偏上方的区域就是这块区域。
对应的uv坐标太不密集了啊！
uv坐标太不密集了，你看这边的个v坐标是不是啊？
非常多呀！
对吧？
非常多，因为对于这样一个你看对于里面的这样一个斜着的这样一个地面的mesh啊！
对于这样一个斜着的地面的mesh来讲。
这个正方形来讲啊，那么你如果正对着它啊，那它就像这样图片一样，那它的每一个像素点，我们屏幕空间啊，屏幕上的每个像素点是不是都对应着一个fragment对吧？
那如果你斜过来的话，会发生什么事儿呢啊？
斜过来的话呢，就会发现啊，这个家伙经过差值之后就这个match啊，经过差值之后得到的这个fragment。
一般是这么多，但是这一边的话，它对应的就太多了啊，对应那么多的话呢，我们啊一旦进行了by linder采样，那么是不是就是一大堆在一起，挤在一起进行平均啊，就会非常模糊。
那么，我们该怎么办呢啊？
就需要各向异性了啊，各向异性我们看在采样的时候啊，将每个像素的屏幕间坐标也考虑在内了，将完全正方形的采样通过计算变换成其他形状的算子。
怎么理解呢？
我们看。
当呃，这样一个match或者是一个正方形吧，它正对着我们摄像机的时候，那么我们的采样呢？
其实是这样的，哎，我们从这张图片啊，得到一个像素，然后呢，对其周边的九个要进行一个加权，平均对吧？
那么得到一个采样，这就是半尼尔。
但是如果说我们是刚才那张图的话，我们再回去看一下刚才这张图是什么呀？
是不是唉？
这整个图片向前平铺了，对吧？
那么我们就会发现啊，唉，我们的采样呢，换一个姿势了，我们的算子就变成这样了。
我们在y方向啊，我们在y方向就是我们在视线啊，前方啊，就是在uv的v方向，对吧？
uv的v方向我们少采样一些，在它的横向上，我们多采样一些。
啊，就变成了一个这种小长方形OK，那这样的话呢，你会发现啊，其实横向上来讲，它的某个程度差不多，然后它的纵向上呢，由于采样变少了，那么它的颗粒感就更强了。
就这样的，那么接下来呢，我们看还有一种，比如说这种，你通过一个45度看一个呃，比如说你的xyz都是一个斜视45度，你去看一个图，看一个正方形。
那么就会产生这样一个斜视效果，对吧？
斜斜的效果那么那么我们的算子也会变成一个斜视的算子啊，那我们看一看刚才那张图片啊，通过这样一个采样就会变得。
更加清晰哎，这张图片不对。
OK啊，应该是这张图片啊，这个变得你看后面的话就很清清晰了，对吧？
就是说呢，它的颗粒感纵向颗粒感就是比较丰富了，但是横向上来讲的话呢，还是可以模糊一些的，是这样子OK？
结果就是啊，各向异性属于显卡硬件级别的性呃级别的驱动功能，那么具体的实现方式各家都不太一样，我们需要的时候就把这个特性给打开就好了啊。
那么，接下来sephora transform这个也非常简单。
那么，在采样的时候呢，如果出现了uv都要超出零到一的情况，那么如何处理？
我们看一下啊，第一种是repeat，你看采样从这零开始啊哒哒哒裁，然后到这呢，结果uv坐标变成了变成了一点一，怎么办啊？
OK，一点一减去一从头开始采是吧？
就变成了零点一哎，又从这开始采样了，所以说这边又又又采过来了，这就repeat没就是反过来啊，反过来采样。
collect age我们看这边采样，从零开始哒哒哒采采到一对吧，发现诶超过了一点一一点二一点三这样了，那么它会以这张图片的最后一列的像素直接往这平刷。
那这边的话呢，就以最后一行的像素对吧？
往这平刷啊，它这边呢，就以这个点的像素往这平刷对吧？
是这个意思，这叫clamp to edge clamp to这个图片的h。
clap to border，如果说从零到一走走走是吧？
走到一这边的这个uv值已经超出了一万，怎么办呢？
那么我们就规定一个颜色作为border值啊，超出这个部分的所有的f都图成这个border值的颜色。
所以说呢，我们发现啊，在零到一范围之内呢uv是可以更长的显示图片的，但是超出了零到一的范围之外的话呢，就会出现我们设定的黑色，就这样子。
OK，那么关于零卖这个三块链，我们就介绍到这里。

