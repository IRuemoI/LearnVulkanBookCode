11-05.Vulkan-抗锯齿原理介绍

各位同学大家好，我们这节课要抗锯齿it is这玩意呢，也叫反走样，我们先大概认识一下走样。
这就是走样，我们看一下这张图片，这个呢，就是把我们渲染出来的那个图片给它放大啊，我们看到了，咦，这边有很多的小细的锯齿，哎，不知道同学们能不能从视频上看到啊，这边有很多小锯齿，这边呢诶，也很明显很多锯齿。
两张面之间这个缝隙诶，也有很多的锯齿，这是什么东西呢？
我们把它放大来看一看，变成像素栅格诶，左边那就能看到一堆的这样子的锯齿是吧？
怎么回事呢？
屏幕啊，毕竟是由栅格构成的是吧？
那么我们做一个形点亮就是点亮，不点亮它就是不点亮啊，所以说呢，你会发现这边就是一格一格一格的。
这好像是我们之前在第一章节当中讲过的，这个bracing ham画直线的算法是一个道理是吧？
它每次呢，只能选择一个栅格把它点亮，这条直线下来。
好那么像这种情况啊，它就叫做an aliens，那么anti aliens就是反走样啊，也叫抗锯齿OK，那么这个大概就是这个样子。
那么我们看一下具体是怎么产生的呢？
产生走量的原因诶，我们先找出来啊，假设啊，我们这个三角形啊，是一个很密很密的三角形啊，在自然界呢，就不能分到带系了，它是一个原子啊，它的原子是这样的颜色排列的。
OK，那么就是一个从浅颜色到深留深到浅的一个过程啊，这是很细很细的啊，好，那么我们的屏幕呢？
肯定诶，不可能这么细，对吧？
那么可能这一堆这一行的，这个三角形当中的一个横行啊，一行啊，就可能就被映射到了这样一个小小的屏幕上啊，我们的屏幕可能只有一二三四五这五个像素所构成的屏幕的一行。
反而要显示那么多的像素，那怎么显示呢？
那它就只能去采样啊，这一行当中的某一些点来决定我到底显示什么颜色，比如这个点采样到这了，那么我们每隔三个点采样一下采样采样采样对吧诶，我们就采样出来了这些东西。
那么，其实官方的说法呢？
就是说啊，频率的问题对吧？
就这个东西的频率太高了啊，我的采样频率又太低了，自然就没法还原出来，你原来这么高频变化的这个样子对吧？
就这个意思。
好，那么我们看一看啊，如果我们去做一个平均值，这感觉会不会好一点啊？
看啊，我们现在还是这么多的像素，这么多的颜色，那么我们的屏幕呢？
还是有这么几个像素点？
诶，那么我决定第一个像素点是什么颜色呢？
我说啊，前三个你一起给我做一次平均吧诶，就平均成这么一种颜色，这三个给我做一次，平均下来是这个，这三个做一次，平均下来是这个。
你看比这个稍微深一点的颜色，对比上面的原来的格要稍微深一点啊，三个平均一下，因为最后一个的影响，然后这三个平均是这个后面三格，平均是这格好了，那么现在我们得到了这样一幅啊，这个啊，这样输出这么一行像素。
大家明显能来看啊，是不是比刚才这个要上顺滑一点，我们看顺滑多了是吧？
OK，那么这个就是其中一种反走向的手法啊，就是ssaa super sampling anti as。
超级采样OK，你看啊，我们现在讲到这儿呢，也给大家说一下，真正的反走向的分析啊，其实要通过很多的这种手法去描述，大家以前也肯定看过很多的教程啊，里面讲什么频域啊，再再到时域变换。
还有采样的这个低通，高通的滤波等等，一些东西全部推导出来，最后啊，是这个原因，但是在咱们的课程当中啊，咱们注重实践，注重理解，注重入门，咱就不去说那些啊，看上去高大上的数学东西了，其实就这么简单，对吧？
三格下来搞一个这个三格下来，平均一下平均一下。
哎，我就抗抗锯齿，抗的非常舒服OK？
那么，这个就是ssa啊，它是怎么做的呢？
你看我们将附近三个像素的颜色做平均进行输出，那么我们得需要两个步骤啊，怎么做呢？
对吧？
当然ssa不一定是就是平均的三个啊，这个我们是举个例子，它可能也就是四个，一半是八个啊，都有可能。
好，我们看。
首先，身旁一张n倍大小的source image啊，我们现在啊，它的长宽可能是200×600，但是我们可以做成200×n，600×n这么大的一张图片啊，相当占内存了。
那么我们呢？
直接把这张图片渲染出来，就是我们的frame buffer这么大，然后渲染到上面。
渲染完之后呢，我们再找一张小图片，就是sop chain上那张小图片啊sop chain多大呢诶，那就是很正常了，200×600也没有那个n了，然后啊，这家伙从source image上进行采样。
它怎么采呢？
比如说啊，我现在呢，有一个像素，它正好呢，通过计算通过比例的运转啊，它占我swot change这张图片上的比例横向是零点三，纵向是零点四。
然后呢？
那么通过这个比例呢？
我就能从source image上找到一个点，那么我把这个点直接显示出来，肯定是不行的嘛，那么又走样了嘛。
所以说呢，我就对这个点周边啊，从这个source image上找啊，它周边呢，可能多少个像素，比如说八×8，比如四×4是吧，找那么一堆像素一起做个平均哎，就决定了我swotation上面这个点到底要点成什么样的颜色？
OK吧，那这样的话呢，是不是全图都一起做了一下平均呃，其实就会呃产生一个比较偏小模糊的感觉啊，但是确实非常清晰啊。
okay，那么我们接下来看一看它的问题，问题也很严重啊。
我们的source image是一个800×500，然后个子又乘以n，也就是说比原来多了n的平方个像素啊，多了n的平方倍的像素啊，不是个啊，是n的平方倍的像素。
那么，每一个像素都要进行fragment shadow，这个fragment shadow啊，我们现在咱们现在做代码里面还没有加光照嘛，还没有加很多的pdr的东西，如果加了很多这种东西的话呢，你想想这个fragment shadow，其实它要做的事情很多。
我们一下子多出来了n的平方倍的这么多像素，需要做f的谁了，渲染效率是极低的。
那么就不能用这种方法了OK pass掉。
接下来我们要看一看msa这样的算法啊msa呢，它一定是啊，要去掉这个问题，我们看一看，我们先说一个引子。
咱们现在换一个想法，观察如下的像素点诶，这个玩意儿，那么其实这个就是一个方差过程啊，怎么过程呢？
我们以前也学过三角形的绘制算法是吧？
对于我这样一个屏幕上面都有一格一格的像素。
每一个像素呢，大家看都有自己的中心点，那么其实这个传统的方法非常简单，只要这个中心点，它在这个三角形内部落进来了，我就认为啊，这个像素应该点亮，于是乎就就成了一片了，对吧？
那自然而然呢，你看没点亮的地方是不是就很绝对呀？
就很硬，要么就在里面，要么就不在，要么在，要么不在，要么在，要么不在，就这样锯齿咔咔咔就下来了。
OK，那么我们换一种想法，想法一是否可以把一个像素当中啊？
咱多放几个点，咱不要老盯着一像素格的中心点了。
咱多弄几个点，我看一看呢，一个像素格到四个点的话，这四个点有多少个落到三角形地点呢？
这样我们看啊，一个像素格对吧？
它有一二三四有四个采样的点啊，说白了说白了就是位置点。
然后呢？
我们发现啊，你看这个地方是全落进来了啊，它里面的话都是都落进来的，对于边缘商店来讲，我们看这个格啊，这个格那么它四个点里面就只落了一个点。
这三个都没落进来，对于我们再找一个这个歌啊，这个歌很有意思，它有三个点落进来了，有一个点没落进来诶。
你看这样分完之后呢，我们是不是可以记录一下哪个点颜色啊？
然后我在这个像素格内做平均不就好了吗？
那我们看这边啊。
我们看这个格吧呃，看一下对应找一找啊。
呃，从这个点开始这个格啊，从这个点开始这个格其实就是对应的这个格啊，这个格对应了这个格，那么这个格的话有三个顶点落进来了，三个采样点落进来了。
有一个点没落进来，它是不是占75%啊？
那么我就把这个这个三角形的颜色是红色，那这也就可以夺色成75%，它的红色哎，就到了这样子了。
哦，那这样的话，我们就从就能从感性上得到了一个结论，就是说呢，我是不是只要把一个这个高山格给摆上四个点，但你也别管我怎么摆的，我可能正儿八经的摆横平竖直的摆，也可能像我们现在图片里面这样子摆摆个小菱形的摆法。
那么我就能够测算出这个格被三角形覆盖了百分之多少。
那么，进而能够决定它的颜色。
这个就是mzmsa的这样一个核心想法啊OK，那么我们看一下它的具体怎么去做呢？
第二个想法啊，咱们来做一个内存八分，就说白了，搞一张图片啊，把这些点的信息都存起来。
那么也就说。
原来咱们可能是一个800×600的图片，咱们现在把它搞成800乘，四×800乘，二×600×2啊，就多了四倍是吧？
一个格里面多了四个点。
那么搞成这样一张大分辨率的图片之后，我只要做到什么呢？
把这些点的信息存起来就好了，那么配套来讲，给这张大图片呢？
我是不是还要配套一个深度缓存呐？
配套一个模板缓存啊？
或者是说配套一个深度模板缓存对吧？
depths。
那么这个东西呢？
深度呢？
也是要四倍的啊，横乘二竖乘二这么一张图片。
那么okay啊，现在呢，我们就可以把这些点的信息存起来了，大家看对于一格像素呃，我经过一拍的渲染过去之后，我就发现。
呃，这一格像素里面所包含的这四个像素啊，这四个小采样点，它颜色分别是这样的红色，红色，红色和一个绿色。
啊，那么这个格里面的颜色呢？
到底怎么回事呢？
是这样子的好三角形啊好，我们知道要绘制一个模型的话，很多三角形嘛，它们其实是走了一个很正常的历史流程啊，就是呃，你你在我上面呃，谁在谁在我下面这种。
那么，通过深度呢，还能够剪裁剔除，对吧？
最终得到了一张图片，得到了一张非常大的图片啊，十个四倍的，这么一个图片。
然后呢？
把它的颜色都记录下来了，我们再看一看，然后我们进入了一个resolve的环节啊，这张图片呀，其实并不是s上那张，而是我们又做了一个car attachment。
让它往这张上去，旋旋完之后把它re solvresolv啊解析到我们的所有成几张800×600的简单的小图片上。
那么，reserve的过程也非常简单，把这四个颜色是不是做一次平均值就好啊？
做一次平均值。
呃，或者是说。
就或者说我们来看一看这个，这个最终怎么做啊？
我们看一看这过程，这三个红色点，一个绿色点，它们都加在一起，零点八+0点八+0点八，我们说除以几啊，除以四是吧，我们就得到了红色值，绿色值是零点八+0点零零，除以四。
OK，那不就相当于一个比例了嘛，不就是相当于零点八乘以个75%嘛，对吧？
然后这个green啊green的零点八乘以个25%。
诶，我们就得到了okay，我们再反向思考一下这件事情很有意思的地方啊，那就是这儿。
这三个红色的采样点，上面的颜色记录啊，只进行了一次fragment shift啊，为什么呢？
我们看这张图啊，这张图呃，虽然我们是把这张图片给一赞成了，上面一个每一个小方格都有四个采样点，然后呢，我们是不是也是在下一页的PPT当中啊，跟大家讲说我们要做一张更大的图片，横乘二四×2，但这个都只是一种描述上的概念啊。
实际上来讲啊，这个过程是各个硬件厂商的驱动，或者是硬件级别帮我们完成的OK，那么在这个过程当中，实际上来讲是每一个大像素，每一个大像素都会进行一次fragment shader。
然后把得到的结果写入到它所覆盖的这三个小采样点上面。
啊，大家听清楚没有？
再说一遍，其实是每一个大像素都进行了一次fragments得到最后的结果，然后把它记录在了它所覆盖的这三个或者两个或者多少个吧，就采样点上面。
进而得到了我们这种东西是这样的。
所以说看啊，是不是就呃，虽然说所占有的内存确实也膨胀了，但是却并没有说进行更多的，所以说呢，存储效率其实是跟ss差不太多，但是呢，它的运行效率渲染效率。
就提高了不止一点点OK，那么我们整理一下具体做法，首先呢，把渲染输出到一个多重采样的图片上啊，我们在做image的时候不是有一个sample count嘛？
那么，这个sample啊，它就可以设置成为，比如说一四八十六六十四等等。
这样就是为它生成了采样点的个数。
OK，那么渲染到这张图片上之后啊，我们也大概跟大家说一下，就是说现在所说的这个只是一个啊，理解上的做法，具体说怎么做是要看硬件的啊，好那么每个像素有n个采样点都记录了颜色信息跟深度信息。
这样呢，也能够进行深度的剔除了OK，然后呢，我们通过一个resolve的过程，这个resolve呢，就是从这张图片上像素点内采样点的记录做平均值，然后得到了普通的图片就是。
s up ption上面这张resolve attachment，所以说我们看啊，回头我们要写程序的时候啊，把这个东西加到我们的程序里面的时候呢，就要多了一个resolve attachment，不光是color和depths OK？
好，那么这个就是给大家来普及一下anti aliens的一些基础的原理，那么尽可能的也是用这种比较简单举例的方式来进行，那么最后呢，也给大家说一句，整个这个过程我们都是说放大呀，怎么怎么着啊？
那这个都是我们的理解上的一种啊，一种说法。
具体怎么做？
还是要看硬件OK？

