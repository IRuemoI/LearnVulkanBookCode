11-01.Vulkan-深度缓存原理详解

各位同学大家好，今天来讲一讲关于depths啊，深度缓存这么一个课题。
深度缓存呢它就牵扯到了在我们渲染管线当中一个阶段，叫做深度测试啊，我们看一看它解决的问题是什么呢？
那么在绘制两个三角形的过程当中，那么我们的系统啊，到底决定如何决定谁遮挡了谁呢？
这句话怎么讲啊？
你看我现在有一堆的三角形啊，有的在前面，它距离我的摄像头近一点，有的呢，在后边距离我的摄像头啊，它就会远一点。
但是呢，这种远近关系啊，它到底是怎么体现在我们绘制过程当中呢？
那么，我们有第一个方法啊，就是叫做画家的画法，我们知道给你一支笔，给你一张纸，你去画画，那么你可以这么做，你可以层一层的画。
远方有一条有一坨山啊，你就用画笔呢，把这个山画好，这就是你的背景，然后第二层呢，你可以绘制一堆小房子，那么房子所占有的这部分像素一定就已经挡住了，后面的山了。
第三次你再绘制一个人站在房子前面，那么人呢？
就会挡住房子，所以说呢，画家的画法就是一层一层的啊，后面的话会把前面的给挡住，这个的话非常容易。
但是我们毕竟不可能把所有的物体进行了排序是吧？
这样的话呢，效率太低了，所以说呢，我们就得要用啊，这样一个深度环的这么一种方法去选择啊，当前这个像素到底是遮挡了后面像素呢，还是说被后面的像素遮挡了？
okay，我们看看深度缓存这个概念。
深度缓存呀，其实前在radar pass的这个这个章节啊，我们就学过radar pass呢，它其实是有好多张attachment构成，那么其中啊，有一个attachment就是depth buffer attachment。
那么所以说呢，其实深度的信息是被写在了一个什么上啊，写在了一个attachment上面attachment的本质其实就是一张image，一张图片。
那么，这张图片呢？
就好比如我们左上角这张一样，假设我们是一个九×9的横角，这么一个图片，那么上边的初始化的时候啊，都是一点零。
诶，正好我们也规定说关于深度来讲诶，它就是一个零到一的，这么一个浮点数啊，代表它的深度，我们规定距离我们越近的，那么它的深度值就越小，距离我们越远的，它的深度值就越大。
OK，我们看一看。
那么，我们之前在推导啊，这个project matrix的时候，我们知道哎，大家回顾一下关于空间当中的一个物体，它的所有的顶点首先会进行一次view matrix的变换，对吧？
那变换到我们摄像机的坐标系。
我们摄像机呢，是看着y轴z轴的一个负方向对吧，然后变化完毕之后，它就进入到了我们摄像机的这个坐标中，那么经过投影到我们摄像机的这样一个近点的平面，我们就得到了负一到一的一个称为ndc标准化设备坐标系的这样一个啊域当中。
但是在vulkan下面呢，我们会把它规划到什么零到一对吧？
我们讲glm的矩阵是把它规划到零到一的。
那么，在每个顶点信息的处理完成之后，得到的z坐标就可以当做它的深度值了是吧？
因为它是零到一。
啊，那么所有的顶点，比如说一个三角形，它有三个顶点，我们计算完每一个点的深度值，拿到了之后啊，我们离散化成一堆的fragment，就是一堆的小像素点。
那么，每一个像素点呢？
经过差值就可以得到它自己的深度，当然也是零到一，对吧？
好，那么我们现在定完深度这件事，其实就是这个零到一的值是通过它的投影矩阵最终投出来的。
那么，关于depth buffer叫深度缓存啊，就是说用来保存每个像素值的image，所以attachment啊，被设置到了以及radar pass当中。
那么，这笔match呢？
就是depth buffer，当然在v当中啊，它肯定有它自己的格式。
okay，接下来我们看一下这个东西的规则，那给大家理一下。
我们看当前啊，这张画布是空的的时候，那么它的depth buffer那张image就全都是一，也就是说最大深度，那么在进行一个单元绘制之后，会与当前的单元的深度进行对比。
如果比当前小，那么就说明什么呢？
你看比如说这边是啊，这边是零点五啊，我们现在要绘制的这个片源，它的深度是零点五，我们跟这个d1对比说诶，零点五比这个要小，说明当前这个像素上目前距离我们最近的也就是零点五了。
所以呢，我就会把它绘制上啊，输出的这个片源哎，我就给它写进去，那写到哪儿呢？
肯定不是写到呃，深度缓存上对吧？
肯定是写到color attachment所对应的图片上喽。
好，写完之后啊，我们用自己当前这个零深度值，再把它写到深度缓存上面，这个被更新了，就是这么一个样子啊，我们现在啊，这三这四个点吧，这四个点啊，都是构成了一个小小的三角形，那么这个三角形呢，它的深度是零点四。
我们发现它要写哦，于是把它画上去，然后呢，用零点四去给它更新了这个深度缓存啊，那么颜色呢，就输出到color dash ment上，对吧？
OK，接下来我们又要画一个物体了，我们要画一个这样一个三角形啊，它是零点三的深度值，那么这个零点三呢，我们发现是不是比零点四要小啊？
所以说在这块呢，这个点上对吧，它可以变成了零点三啊，这个深度缓存上就被写成了零点三。
其他的地方同样对吧，你看诶比这个要小，所以说就把它更新成了零点三，并且这个片源不丢弃。
那么，如果说我们在这个点上发现又要去画一个三角形了，比如说在这边啊，我们又要画一个啊，这个三角形我们发现说呀，这个三角形的深度值是零点五啊，零点六吧，零点六。
那么零点六呢，是比这几个片源目前记录的深度值都要大呀，说明什么？
说明它离我们远，对吧？
离我们远的话呢，那么自然而然它的这个片源啊，就会被丢弃掉就不要了。
ok，那么就是这么一个简单的方式啊，那每次在绘制之前都要把这个深度缓存的八块给它清空一下啊，什么叫空呢？
就清成一清成最大值，然后再来一遍。
okay，我们看一下这样一个流程啊，我们首先要对系统当中啊，加深度缓存所对应的图片对象。
那么，它其实就是一个Vicky image，那么我们都知道它都有自己的格式是吧？
rgb啊rda啊等等，那么MS打法的格式就是这三种啊，我们都可以，我们看一下。
d32 float呃d就是depth是吧？
32位的一个啊，这个32位都用来记录这样一个深度值。
第二种呢，是d32s8 an int，然后是d24s8 an int哎，这些格式啊，为什么就剩下两个都有一个s8是什么东西呢啊？
我们看一看。
它是把同一个信要素啊，表述信息。
嗯，如果你学过ogl，你知道啊，在这个关于深度啊，深度方面它其实呢是跟另外一种概念啊，混合在一起存储了。
那么，另外一个概念就叫做啊模板测试啊模板的buffer 38分呃，关于模板呢，我们可能在后面的这个课程当中会去介绍啊，因为在这个课程当中呢，东西已经很多了啊，希望大家这个东西呢，它啊可能不如我们现在所讲的东西重要啊，所以会在后面说。
呃简而简而言之啊s ten这个stencil这个模板测试啊，其实也是一个数啊，这个数呢，它其实就是一个int值啊，或者说是一个呃八位的int，或者是一个什么这种感觉啊，就是一个数字。
这个数字呢呃，它往往啊，也都是一个pass下去做更新的，那么由于啊，我们当前这一个像素啊，这个图片里面的每个像素啊，它的这个整个所占的比特值是很高的。
所以说呢，我们就可以啊，把这个深度缓存所用的这个buffer跟我们stencil就是模板缓存的buffer放在一起，各管各的啊，同一个像素值，我们看这边可能它的高32位是个哎x，那第八位可能就是个什么呀，可能就是个啊这个。
s tension同样这边是高24位，是float这边一八位是一个啊int的s tension，那么我们这节课呢，肯定就只关心这个嘛，对吧？
我们不用关心它啊，它也不会去开启这个s tension的用处。
只不过它在这边上可以用来记录两种信息，而我们现在的选择是哎，就关心它就好了okay？
那么，所以第一步建立一个image转换成深度缓冲使用的layout啊？
那么，接下来我们看在render pass当中，我们复习一下啊，render pass当中呢？
我们有一个attachment description，就是描述当前这个attachment所有的信息，那么这一些attachment呢，会被包装成attachment reference，对吧？
reference呢？
它会哎，这个引用。
这个它这么的数组当中哪一个？
好，那么我们目前呢？
就是在里面又要加入一个attachment 2啊，对二号attachment来表示深度，而这个attachment呢？
我们又可以区别它的是不是啊？
以它的这个initial的呀，它的final的呀，它等等的信息。
那么这个东西呢？
它就会被作为啊，这个depth attachment设置到sub pass里面去用啊，每个sub pass它都要去用，它作为深度来进行记录。
啊，并且呢，自动进行判断。
那么，我们还要注意一点啊，在写程序的时候呢，还要为其加上一个clear color啊，那么这么说这么说吧，就是说啊，我们如果有三种attachment，那么我们就要给segment呢，做三个clear color对吧？
每一个的clear color不一样。
颜色的话呢，可能或者是说形成你需要的背景颜色那么深度缓存呢，我们就给它设成一就好了。
那么，看frame buffer，我们还记得frame buffer吗？
啊frame buffer的话呢？
就是把一堆attachment image啊，image view可以说啊，让他们做一个集合打包一下啊，打上一个数组，然后呢，形成了这么一个frame buffer送给dpu。
好，那么这里面也需要添加进去一个adapt ment image，这个就是depth buffer所用的image啊，加到这里面，所以说大家记得吗？
这个是描述信息是吧？
这个就是真正的为d image view。
好，那么最后啊，我们就需要在pipeline里面去打开，我说我要去启用啊，这个depth test功能，所以说这边的话呢，就要去depth test enable=vk two depth right enable=vk two什么意思呢？
APP text就是说我当前所绘制的这个三角形呢，它所删掉画成的像素是否要参与我们的这个深度测试？
如果你说make a FALSE的话呢，那么OK啊，它就我管也不管你这个下面到底是深度比较还是比较大，反正我书说了，我就直接往上画啊。
这个意思depths right enable啊，那么就是说呢，我们刚才讲啊，如果说我这个像素它离摄像头更近，它的这个depths更小，那么是不是它不仅要着色，而且还要去更新啊？
这个我们的depths buffer呢？
那么这个意思就是说呀啊，就是我这步操作完之后，如果说我通过了深度测试，我也不去洗录debs buffer，我也不去洗录debs buffer啊，那这个这些其实这种灵活配合的用法蛮多的，这边给大家举个例子啊。
嗯，那就是说呢，如果你画一个这个透明的物体，这个透明物体呢，它一定是要啊，先画这个非透明物体，我们再画透明物体，嗯，透明物体的话呢，我们看到说诶，这个如果说当前啊，这个。
现在的这个color，它上面上的颜色呃，当前要素所对应的这个深度，如果说比我小，那么我就丢弃了，我被挡住了嘛，如果比我大，我就与它颜色进行混合。
但是呢，我并不写入啊，但是我并不写入。
那么，我为什么作为一个透明物体啊？
我不去写入我的深度值呢？
那是因为啊，如果我写入深度值，假设在透明物体之上，还会这里一个透明物体。
啊，或者说呃，在一个投入体型绘制完毕之后，那么在它的后面啊，又要绘这个透明物体的时候。
像这些啊，像这些比较奇怪的，这种绘制方式是吧？
你就需要不让它写入你写进去之后，它后面的物体就会不上了，当然这个关于透明物体都是排序的啊，远及近绘制对吧？
这个给大家一定要注意，我刚才只是说了一种比较极端的小情况啊。
那么，最后一个参数depth compare operation啊，这是一种对比的行为呃，我刚才讲了那么关于深度比较浅比较小的值是会覆盖深度比较大的值的。
但是某些情况下，我们也希望反过来说，如果说当前这个物体的深度值啊，它比这个代子打法上的深度值要大，我才绘制它啊，那你这样的话就需要用compare great了。
这个的话呢，你像这个的话，什么意思啊？
就是说啊，比它小才进行绘制啊，才进行写入，并且绘制啊ok，那么这个值的话有很多种，大家呢，也都可以在写程序的时候啊啊，直接进到它的定义域里面去看一看到底有多少种的操作。
啊OK，关于这个深度检测呀，我们就大概说到这啊，再给大家补充一个点啊呃，深度检测执行时间，这个也非常微妙啊，大多数的这种现代化的显卡比较好的显卡啊，它都是支持叫做early leave。
2 dz是什么意思呢？
二二d就是走，然后杠z这个东西呢？
就是说啊，它可以在进入fragment 11代之前啊，在光栅化之后和进入fragment 11代着色之前，这段时间我就可以去进行深度的判断了。
那么还有一个是late z啊，那么就是说在fragment输出之后，那么我才进行这样一个深度检测的判断，你看前者有什么好处呢？
前者就是可以提前进行深度的剪裁，唉，把那些不需要着色的像素全部抛弃掉，就是discard掉，对吧？
然后呢？
那那么说什么情况下才会啊？
无法进行这样的操作呢？
呃，在这里给大家啰嗦几句啊，也是我们在实战当中遇到的情况啊，什么情况呢？
呃，比如说我要绘制一堆三角形，而gpu是一个病情的，尤其是在薄痕情况下，病情非常严重，对吧？
呃，我现在画一个角形，我就栅格画完毕了，可能跟我同区域的三角形还没有栅格画上，那么我要等待它做early day吗？
那么肯定不等它了，对吧？
我就直接就去着色了，我才不管你呢啊，所以说呢呃，这个二类z啊，它是在一些比较巧合的情况下的一些优化啊，进行一些优化。
OK好，那么我关于身体检测就给大家讲到这里。

