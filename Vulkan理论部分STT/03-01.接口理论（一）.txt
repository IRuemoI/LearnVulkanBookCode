03-01.Vulkan-接口理论（一）

好，各位同学，大家好，那么这节课开始呢？
我们介绍一下walk en的接口理论。
在正式进行编程之前呢，我们要先把vulkan的整个设计体系给他讲授一下，包括说很多API的设计，很多对象的设计都是干嘛用的啊？
因vulkan的接口太碎了啊，太多了。
OK，我们先看一看啊，在vulkan t里面呢，有一个概念是host and device翻译过来呢，就是客户端与服务端，或者称为逻辑端与渲染端。
当然也可以讲是CPU端与gpu端啊，那么host是指什么呢？
一切CPU与内存为基础进行的操作都是host端。
啊，那么这个所谓的host跟device？
或者是说呢，host和server啊，什么意思？
我们可以把gpu理解成为一个服务端啊，一一个服务器，或者是说一个，比如说一个服务员。
我们的CPU端呢，也就是host，比如说我想画一帧东西啊，我想画这个小人儿，我就会把数据丢给你去处理，你处理完毕之后呢，然后就给我显示到屏幕上，那么感觉上好像是host就是客户，然后。
gpu呢，就是一个服务端呃，一个服务员的感觉，那么在host端进行的操作，比如模型读取啊，肯定就是CPU指导的内存向呃，硬盘上读取模型对吧？
不会有什么gpu的参与。
然后鼠标键盘事件的响应，然后我们的游戏碰撞逻辑，包括说很多定时事件啊，都是在host端执行，然后device端一切由gpu以显存为基础进行的图形渲染后处理等工作都是device端。
啊，图形渲染很好理解，那么肯定是在gpu工作了，显存里面存的是什么呢？
存的就是顶点的数据，这些数据哪来的呀？
是从CPU读完模型之后啊，发往gpu服务端的。
然后存到它的显存里是这样子，然后所谓后处理是指什么呢？
就是我渲染完一帧，然后呢？
我要把它变模糊，把它变成黄昏的风格等等啊，类似于PS的功能。
那么后处理也是在gpu进行的。
我们看这个是host端CPU内存，这个是device端gpu显存，那么我们写一段小程序，这是一个loop啊，这是一个循环，然后呢，我们要做三件事，做完三件事呢，然后发一个render指令。
就是说白了，就是掉了一个render函数，比如说然后呢，在CPU端就是host端会挨个执行，比如说我更新了一个子弹的坐标，我更新了一个谷歌动画的啊，它的一个帧。
啊，以及位置，然后我又更新了一个什么东西，对吧？
比如说粒子，然后呢？
我把这些更新的数据啊，都肯定先更新到哪里啊？
内存再有内存。
发往do rendering这个函数里面编程命令，然后由这个do rendering把我要做的这些信息全部发往哪儿等于外端，然后显存里面存下来gpu来并行流水线执行这样子。
好，那么我们看一看啊，在vulkan里面啊，它是存在着很多很多不同的这种嗯，怎么说呢，这种对象的啊，我们一个一个看，首先要看的对象叫instance。
用来表示渲染程序的源数据，比如w的版本啊，引擎的版本啊，是否启用debug呀，也就是layer的概念啊，是否启用哪些扩展啊等等都是instance。
那么，这个instance呢？
为什么称为原数据呢？
我们经常在很多程序设计的这个课程啊，包括说很多体系当中啊，都能看到原数据啊，它描述的其实是一种更加的呃信息，更加的偏向信息，这种感觉的这样一个一套数据啊。
那么呃，也很像那种上下文的感觉，也就是说呢，在我们程序运行的过程当中啊，可能时不时的要过来用一下啊，类似于全局的一个全局的一个变量啊，或者说全局的一个table啊，里面存着很多的东西，我用的时候取一下啊，这个就是原数据的概念。
也是表示了它最本质上的东西啊，第2 surface啊，surface是干嘛呢？
它是用来链接操作系统相关的窗口与walk in渲染出来的图像组件啊，这是两件事啊，你看啊，操作系统相关的窗口，首先它在哪里啊？
啊，它肯定是在内存当中会存这些东西，然后在显存里面呢，再去存窗口相关的数据，然后再渲染到咱们的窗，咱们的这个这个显示屏上是吧，比如WINDOWS啊linux啊等等都这样。
但是呢，如果我们想生成一个窗口啊，就得去调用linux或者WINDOWS或者安卓等等啊，它们不同的API对我们来说很麻烦啊，当然malkin呢也做了相关的封装，我们调一个函数就可以了。
那么这个窗口啊，它与渲染还是两回事，窗口是窗口对吧？
与操作系统相关渲染呢？
我是渲染到了一个，比如说是一套一块内存啊，假设有一块内存放在这啊，它是一个800×600。
然后呢，每一个像素格都是rgb 32。
那把这个内存填满数据，就是它渲染完的一个过程啊，那这块内存在哪里呢？
在gpu上对吧啊？
在gpu上那渲染完毕之后啊，如何把它显示到当前这个窗口上呢？
那么就得用surface这个概念了啊？
surface呀会负责啊，把这些数据啊。
连连通到咱们当前的窗口上，也就是说这边我gpu哎宣传一帧了，那边就可以在当前的，不管你哪个系统啊，跨平台了，然后给你显示出来啊，这surface。
然后是physical device啊，physical device用来代表一张显卡，我们可以挑选用哪一张显卡运行，因为现在我们的电脑应该都有极显，独显，甚至两块独显啊，那么我们呢，可以通过程序里面啊，对显卡的一些特性的分析啊，大家记住一定要特性的分析，具体什么样的特性呢，我们在程序里才能看到，对吧？
然后挑选出来一张显卡，然后用它啊来进行接下来的渲染工作，这个physical v八四代表的是物理设备。
然后呢，就是local device啊，local device呢，属于device端啊，我们申请一个资源之后呢，用逻辑设备在host端，就是在我们CPU这边啊，远程的操作这个东西啊，其实在这边生成的都是什么叫聚丙啊聚丙。
什么是句柄呢？
句柄可以这么理解啊，类似于一个编号，我们一般图形的API，比如说啊，叫做create啊，比如说我们说一个create command啊，类似类似于这样的API，那create command API呢，就需要传进去一堆的参数，对吧？
然后调这个API的时候呢，我们就在想啊，它到底发生了什么呢？
对不对？
我好像只是传了一个instance，传了一个呃什么surface，或者传了一个local device进去，它就给我噼里啪啦生成了一堆什么东西，怎么就生成了呢啊？
那是因为instance啊，在这边可能是一个编号。
这个编号，比如说是15号，那么在这边啊，可能有一块内存啊，到了显卡这边一看哦，要对15号进行什么操作了，好他就回去找啊，15号编号是在哪块啊，在这块把它找到，然后去运行。
啊，是这种意思，所以说在这边啊，我们也存一个句柄，就是logical device，它是用来远程操纵这个，这个代表这个显卡硬件的啊physical device。
okay，那么接下来我们看一下基础设施当中的交换链，假设我们这是一个屏幕啊，我们现在解释一下，一个屏幕上面去显示一幅图片的原理。
首先呢，这边有一个真数据啊，我们可以把它理解成为一个buffer，或者是一块内存，这块内存上呢，已经被画满了rgb的颜色，现在啊，我想把这块内存上所表达的图片去显示到这块屏幕上，怎么显示呢？
屏幕上都是像素，它符合从左到右先渲染第一行，然后啊，它再把这个渲染的这个，比如说指针啊，再移到这来，然后继续渲染第二行，这样扫过来渲染第三行渲染每一行的时候呢，都会啊，从这个帧buffer里面去取数据取出来，然后渲染出来取出来渲染出来是这样子。
一直渲染到最后一行啊，然后呢，再回来到这儿啊，再从这儿右下角回来到左上角，然后再一帧一帧渲染，但是啊呃，有些问题啊，在介绍问题之前，我们先介绍一下这个效应啊。
水平消隐时间是什么意思啊？
我们看从这一扫描这一行去点亮点亮点亮点亮走到这，但是走到这的话，对于对于怎么说呢？
对于设备来讲啊，它要去转到这一行这个地方啊。
准备好，然后再开始重新扫第二行这个，从这个点上转到这个点开始进第二行扫描的这段间隔时间，我们称为水平效应时间扫一行，然后移过来水平效应时间，然后去扫第二行水平效应时间第三行，然后一直到最后一行。
啊，那么垂直效应时间是指什么呢？
是指这一页啊，都扫描完毕了啊，都已经显示完毕了，然后从右下角再回到左上角的时间称为垂直效应时间啊，就是这个工这个过程是在做准备工作。
然后呢？
问题来了啊，如果在垂直效应来临之前，我们就去更新了这家伙，那么就会产生撕裂的这块屏，什么意思啊？
我们看呃渲染的速度，或者说显卡执行的速度，可是远远的比这个屏幕显示啊，刷新的速度要快的，那么如果说人家在这边刷新着呢啊，一行取完颜色，然后显示出来，第二行，第三行。
那么，在第四行的时候，我们就把这帧帧的数据更新了，变成了下一帧的样子了，那么是不是从第四行开始渲染出来的？
就显示出来的就是下一帧的数据了，而上面三行还保持着原来的数据，对吧？
那么就惨了啊，就会产生撕裂感，那么所以说啊，我们必须等垂直效应时间才能更新帧数据，为什么啊？
大家看我们首先啊，忍着不渲染啊，慢一点阻塞在这啊，渲染完一帧等着，然后呢，它从这取出去一行两行三行的不停显示显示显示到最后到这了啊，我们显示到了最右下角。
然后呢，从下角开始，我们进入了什么垂直消影时间，在这段时间我们又选了一帧新的数据，这时候呢，刚好我们也要从是不是从头开始又要读数据再显示了这样的话呢，不会产生撕裂啊，不会把两帧的数据划到这样一个板块上，甚至是多帧的数据划到这一个屏幕上，对吧？
钢化几行就就下一帧了，钢化几行下一帧了，就会一个屏幕上就会很多数据，但这样的话，我们通过垂直效应时间的控制啊，就可以这样子再更新完一帧啊，这样显示完一帧才去更新这个buffer，然后水平消炎，再读新buffer的东西显示。
到这了，再要回去的，这个时间又更新了一帧，对吧？
这边又更新了一帧，这边正回去，这边正更新是吧？
这边正更新那么，但是这样却很慢啊，因为刷屏的时间加渲染更新的时间就等于真的时间了啊，这边要等着这边要这边要刷刷刷，然后回来等着，然后这边渲染完数据，然后再刷刷刷很慢。
对吧，这样效率就特别低，那么我们提出这样一个办法啊，双buffer缓存啊，我们拿出第一个，我们在gpu里面放两个buffer buffer，一是用来给屏幕去显示的buffer，二是给gpu去渲染的啊，那么我们看。
在这边该选它的选它的，是不是对这个buffer 1不影响啊？
那么当这个屏幕现在一行一行的在扫描，走到右下角进入水垂直效应时间的时候。
那么这时候我们把buffer 1和buffer 2的位置给更换一下，然后呢？
buffer 2就变成了是不是被屏幕空间读取的了？
buffer 1就用来被渲染了？
那这样的话是一个无缝接入啊，无缝接入我们是不是只用考虑考虑从这个点一直刷到这个点的时间就可以了？
对吧，所以这个过程就是交换链完成的啊，那么我们看一下啊，交换链在host端，我们增加这么一个对象交换链，它在device端就是显存里面啊，我们假设有三块buffer。
那么，交换链这个对象呢？
其实就是管理了显存当中的n个渲染拔块交替使用，比如说我们举个例子啊。
如下所示，这是一块屏幕，这边呢，是gpu的一个队列，上面是三个八块，此时我们先渲染八块，一渲染完毕，八块一被放到队列，那么屏幕呢，现在开始读取八块一的数据，并且显示。
那么，在它读取buffer 1数据显示的过程当中，buffer 2也开始被渲染了。
此时buffer 2渲染完毕，进入对列。
进入队列之后呢，我们看此时呢，是不是该显示buffer 2了，对吧？
然后啊，屏幕空间进入垂直效应期，刚好进入垂直效应期啊，要开始回去的过程了。
此时把buffer 1拿出来，把buffer 2要放到这个位置，对不对？
但是啊，与此同时啊，由于buffer 2已经被放进来了，所以说在buffer 2不啊，在buffer 2你看在这段时间之内啊，已经没有什么真可以用了，只能用buffer 3了，对吧？
所以说gpu又会给8f三去画东西了。
那么，此时buffer 3也画完了，然后buffer 2该被显示了，于是buffer 2被推过来。
buffer 3也进了规定。
那么，此时屏幕空间消隐完毕啊，又从buffer 2里面去读，然后呢？
诶buffer 3又被推过来继续对吧？
在buffer 2读取完毕之后。
它进入垂直效应期间，我们就可以更新下一帧了，就这个意思，然后此时啊，在buffer 3被显示的过程当中，buffer 1又被画完了。
然后呢，八号一推入队列，等待显示OK就是这么一个过程好，那么这节课呢，我们介绍了这么几个东西instance负责原数据surface负责窗口与我们渲染之间的画面连接。
logical device负责远程操纵gpu端的的物理设备，负责在控制啊屏幕的显示与我们多把本之间的交替。
okay，那么这节课就到这里。

