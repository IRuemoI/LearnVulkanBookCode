03-02.Vulkan-接口理论（二）

好各位同学，大家好，我们这节课啊，来继续学习vulkan的接口理论，那么上几节课呢，我们已经知道了啊vulkan里面有，比如instance啊physical device sweep train啊surface，还有logical device。
那么这节课呢？
我们开始接触shadow啊，那shadow的话呢？
其实呃，如果是学过二分GL的同学啊，尤其是核心模式是吧，其实对shadow已经比较了解了。
那么，渲染的过程啊，就是一个通过渲染管线啊，就会产生对顶点以及片源。
大家还记得片源是什么吗啊？
其实就是三角形在变成屏幕坐标之后，就是进入到平面之后，然后离散化成为一堆像素的过程啊，这是最后得到的每一个像素就是一个片源啊。
那么，会产生对顶点及片源的处理行为，那么控制这些处理过程的gpu端编程语言就成为she der着色器语言，那么我们来深入的看一看啊shed dar主要分为我texts dar跟fragmented she dar以及还有很多其他的she dar。
像什么呃，曲面细分啊几何啊computer啊等等啊那么举例？
我们先用一个小小的例子来感受一下谁的耳，现在呢？
比如说我们已经拿到了一堆三角形的顶点了，那这堆顶点是不是就要被直接送入管线了呢？
对吧？
呃，那么前几节课我们讲理论的时候说呀，每一个顶点需要从三维坐标系变到哪啊？
变到摄像机坐标系对吧？
再从射向坐标系投影到咱们的平面上，哎，这个过程啊，就是咱们shade的第一个阶段叫vortex shade啊，就是在这个shade里面做的。
那么我们呢，就可以写一个我text shader的这么一个程序，那gpu啊，拿到这一堆顶点的数据之后呢，就会把这一堆顶点数据啊给并行的啊，并行的进行处理。
那么用的这个处理的逻辑啊，就写在咱们这个vortex sheet r里面。
那么有一个三维的点x被送入管线，肯定要进行MVP变化，对吧？
首先是model矩阵。
model矩阵是什么呀？
就是把这个把这个呃模型啊平移旋转缩放，然后呢，再进入view矩阵对吧？
那么就是说。
转到视线坐标系，然后再投影projection变换，那么可不可以进行一些好玩的特效，或者说一些有意思的东西呢啊，比如说每个顶点啊，进入管线之后啊，它不单是说朝你这个矩阵变换到屏幕上。
而是说呢，被扰动一定的位移，也就是说呀，我们在三维坐标系当中这个点啊，那么把它比如在xyz上随机移动一个小位置。
啊，那么就产生了一些很好玩的东西是吧啊，我们输入的形状可能一直在变，那么就需要在我太子鞋带部分进行编程了，就这个意思。
好，那么接下来呢？
我们看一看啊，从我tax谁的到fragment谁的，那么这两个谁的到底是怎么玩的？
首先呀，我们看一看我tax谁的啊？
我tag阶段呢，咱们仔细看看啊，首先它有一个w四五零，就是说呢，这是用了一个四五零版本的glglsl啊，这个是一点的语言书写格式啊，就叫glsl啊，我们在vulkan里面呢，其实也可以用glsl写，但是需要再被编译一次。
具体处理的过程啊，我们后面看，我们先看这个代码，第一行layout location=0啊诶，我这边我觉得要对修改一下比较好啊，这个是应该是。
location=1啊，修改一下好location=0in wax4in position啊，什么意思？
就是说呀。
传进来了一个，其次坐标对吧？
这是一个那么一堆顶点当中的某一个顶点的位置，然后呢？
以及这一个顶点的颜色，然后呢？
我再通过这个叫做ubo的东西uniform变量啊，这个uniform变量什么意思呢？
就是说呀，它是一个专门设置的，就是通过C加加语言啊，直接设置到c的里面的一个变量，大家可以暂时这么理解啊，然后呢？
传进来了呃，这个顶点它的model view projection矩阵。
然后呢？
我们这边有个out啊，我们想对外输出什么，或者说像fragment shed a里面输出什么呢？
我想输出呀，这个顶点的颜色。
OK，那么我们输入是这三个东西，输出是这一个东西，这个输出是向下一个阶段的输出，然后呢，进入main函数开始执行，那怎怎么执行的呢？
首先GL杠position，这是一个什么呀？
这是一个内置变量。
啊，这是内置在谁袋里面的？
或者是说内置在我们管线当中的一个公用变量，这个变量就表示啊，我通过这个谁袋处理完毕某一个顶点，那么处理后的结果存在里面，由它呀，直接向后方进行传递。
然后呢？
我们这个全局的变量等于什么呢啊？
这个内置的变量等于什么呢？
等于你输入的这个顶点的position先进行一次平移旋转缩放啊，这种总体的model矩阵，然后转化到摄像机坐标系。
然后再去转化到屏幕空间的ndc，但是大家注意这个projection矩阵得到的是什么呢？
是不是还没有除以omega的那个数？
没有除以omega的那个，其次坐标系的。
四维向量对吧？
然后我们要向再输出一个什么东西呢？
首先啊，它已经自然而然的就会被输出到后面去了啊，然后它呢是我们刻意要输出的，我们定义的，我们输出这个color=in color，也就是说原来是什么颜色，我们向后输出这个顶点颜色，它就什么颜色。
好了，我们再看一下fragment sheet呃，大家先不要把它俩之间产生任何的联系，我们先独立的看在fragment sheet里面呢，我们in vector 3 fragment color啊，输出一个vector four out color。
那么，我们in什么color呢？
是不是就是从这个谁的里面传过来的那个颜色呢？
好像并不是，为什么因为啊？
当之前这个谁的处理的是单个顶点。
比如说我们有一个三角形，三个顶点，那么gpu是一个流水线的运作，是一个并行，所以说这三个顶点啊，会被一起通过这样一个fragments hee tr啊并行处理掉。
但是你再怎么处理啊，你也只能得到三个结果，对吧？
你输出了三个这种position，然后呢？
再输出了三个颜色，但是这个fragment 11代人家处理的是什么呢？
处理的是啊，你这个三角形被光栅化成网格了。
被光栅化成像素了，被光栅化成片源了，对吧？
在每一个片源上执行了这样的fragment sheet，一个三角形可能会被光栅化成，比如说几百个这种小栅格，每一个这些几百个栅格啊，每一个都会运行这个，而且是并行处理。
啊，又是并行的，你看它并行处理干了什么呢啊？
你告诉我输入了一个这个栅格的输入颜色，大家先不用管这个输入颜色哪来的，反正肯定跟它有关系，对吧？
输了一个什么颜色，然后呢？
我输出一个这个颜色，那么我输出的这个颜色啊，这个out color啊，那会输出到哪儿呢？
它其实就是直接输出到了这个画布上啊，输出到了画布上可以这么理解。
okay，那么我们知道了它是对顶点变换啊，它呢，是对每一个栅格进行处理okay。
我们把我太太身段中指对每个顶点做变换，并且把每个顶点颜色输送到下个阶段，对吧？
问题下一阶段被光山画成三角形，内部的片源啊，那每个颜色怎么确定呢？
就是我们刚才这个问题啊，我这是一堆小栅格，每个栅格的颜色是怎么确定的呢？
也就说你这个in color啊。
啊in这个fragment到底跟你输出这个out color到底有什么样的关系啊？
我们来考察一下这个啊，就是fragment我test谁点输出的啊？
三个顶点对吧？
然后啊，输出之后再进入fragment谁点之前？
会被栅格化诶，会变成这样子，那么这三个数三个向量代表什么呢？
代表三个顶点的颜色rgb啊，这个红的这个是green绿的，这个是blue蓝色的点。
那么，栅格画成这一堆之后啊，我们提出一个问题啊，中间这个小点所代表的栅格，它到底是什么颜色呢？
唉，这个就涉及到一个概念，是差值在我test谁点输出之后fragment谁点输，输入之前会进行一次删光栅化。
删格化之后呢，会对每一个格格里面相关的变量进行一个次差值运算，它是这么做的。
如果我要求这个小格要输入的颜色是什么，那么我就从这画一条直线啊，画一条直线之后呢，我能够知道唉，首先我知道这个点的y坐标是30，因为它在屏幕上嘛，对吧？
就有y了xy了y是30，这边的y是零，这边的y也是零啊。
那么我y左边的这个焦点的yl啊，它的坐标是十右边的这个焦点肯定是十喽，然后假设啊，这边的color这个点啊的color应该是color l这个点的color是color r啊，那么我们要先求出来啊。
从这个点画直线之后呢，相交的这两个点的颜色啊，先说这两个颜色，我们先把精力啊，注意关注到这个color l上，哎，我们是这么算的，假设呢，这个点的红色，我们怎么去算？
呃，我们可以这么看啊，式子已经给出来了，但这个式子什么意思呢？
我们可以这么理解。
这个点啊，它的y坐标啊，是在这对吧？
然后呢？
这个点的y坐标啊，是在这那么我们想这么求啊，想说呢呃，这一块的长度占总长度的比例。
啊，这块的长度占总长度的比例，那么我们怎么算呢？
这么算啊yl这个点的y值减去它的y值比上这个点的y值减去它的y值，哎，不就是说这个点在这块长度上所占的比例嘛，对不对？
乘以了r1-r2r一是什么呀？
r1是不是它的红色值减r2？
那么r2就是它的红色值，说白了什么意思呢？
这一个相减得到的结果是这两个点的之间在r上的总距离，在红色分量上的总距离。
然后呢，再乘以一个这段儿占有的比例，不就算出来了，这一个点距离这一个点的红色变量的啊红色。
红色这个分量上的什么的距离嘛，就是说这个点到它哎，差了多少红色是这么个意思，然后呢，再用这个点的红色加上两个点之间的红色差距。
就得到了这个点，上面的红色是这么个意思啊，就是呢，因为我们的这个这个几何上啊，长度啊啊，或者说坐标上是线性变化的，而颜色也是用线性差值的，所以说这个过程就是叫线性差值啊，线性差值。
同样的算法啊，同理，我们可以计算这个点的是不是R级b分量上的颜色，然后我们再把刚才是用y做计算对吧，我们再在横坐标上做一次计算，把这两个点的。
坐标是不是可以求出来啊？
求出来之后呢？
这两个点上的颜色我又已经知道了，那么同样的算法对吧？
它到它的距离，那么它到它的距离做一个比例，那么呢，再用两个点之间做一次，哎rgb分量上的差值啊的差求出来。
再用这个比例乘，再拿这个初始的点一加，哎，不就出来了，对吧？
这个颜色就出来了，在这里啊，不要给不给大家讲的太细了啊，因为这个在我们澳门GL这个原理课上就已经讲过了，呃呃，不明白的同学可以通过这个式子仔细思考一下，推而广之就能得到这个答案。
好，接下来我们介绍pipeline啊，pipeline的话，以前给大家说过啊，就是这么一堆的过程，其实vulkan里面是把pipeline这件事啊，封装成了一个叫pipeline的对象。
它负责什么呢啊？
宣传管线在lock里面选一个对象，代表了顶点，一直到屏幕上显示成像素的整个处理过程啊，流水线的一些参数方面的设置都是在pipeline这个对象上进行设置的。
理解啊pipeline啊，它一般啊，都跟材质挂钩，大家应该都听说过材质对吧？
就比如说呢，这个材质应用到这个物体上，这个物体就变透明了，或者是这个物体呢，就变成实体了啊，或者是说它上面长出来毛了，等等啊。
都属于材质，所以说一般情况下啊啊，包括说这个这些顶点啊，组织成的是面还是线，其实都属于材质的范围，那么结论在渲染管线当中啊，这些参数都会被一一设置，也就是说呢，你看你设置是不是透明啊？
干嘛的？
是不是通过这个混合与测试就行，对吧？
混合嘛颜色混合？
然后你想去设置光照，怎么向对光照进行响应是吧？
每一个小像素对光照怎么响应？
你就在片源着色里面就啊进行着色，你把它装配成线还是面呃还是三角形唉，就图源装配对吧，所以说呀，它这个排出来对象就暴露了很多参数，供你设置。
在这样一套过程当中如何处理？
所以说呢，在我们真正编程的时候啊，可以写一个我们trl类啊，材质类来维护自己的pipeline好，那么这样的话呢，我们就在里面哎，就加了一个pipeline对象啊，好，我们再介绍一下render pass啊。
呃rin de pass它其实解决了个什么问题呢？
在这个w里面rin de pass也是一个对象，它解决一个问题是本次渲染要输出到哪个画布上，因为我们是不是可以做很多很多的image啊？
做很多的图像，很多的image，每一个image都是一个画布。
或者是说都是一个八分，那我这次渲染要输出到哪呢？
或者说本次渲染要分多少批次呢？
有可能啊，我会比如说defer的认定延迟渲染。
它会把光照这些信息啊，先渲染到一个buffer上，然后呢，再用这个buffer作为输入，又渲染了一次，到了我们最终呈现的那个buffer上。
那么，这就是渲染了两次，而形成了一帧图像。
那么，解决这个问题啊，就是控制这个流程上的东西，就成为render pass。
所以说呢，pass指定了渲染目标版本，我到底渲染哪去？
批次我渲染多少次？
中间有没有一类啊？
是不是上一个渲染完的图像可以呃不去显示，然后呢？
再拿这个结果去显示去渲染下一帧的东西？
那么，把下一帧显示出来啊，就是渲染好几次，渲染好几个pass，然后得到了一张我们的图像帧啊，这么个意思，所以说render pass就是控制这个过程啊，具体的细节我们可以看到在后面。
okay，所以说我们又添加了一个成员啊，是伦达帕斯okay，那么这节课给大家讲到这里。

