06-02.Vulkan-SubPass与依赖详解

这节课啊，要讲的是surpass及其依赖，那么这个呢，也会作为啊，我们来讲解walk in的这个同步机制的一个入门课程，或者说一个体验啊。
我们看一下，具有一定的同步机制，那么为了提高gpu的一个吞吐量locken，就引入了管线的同步机制，我们举个例子啊。
呃，当前这样一个是没有进行管线同步的操作，首先我们有一个萨博帕斯零这个零号呢，三个阶段要执行，那么它输入的是一个color attachment 0对吧？
输入进来之后呢？
它会啊，进行系列的操作，然后呢？
把这个颜色呀都写到这个color attachment 0上。
最后啊，我们有一个sub pass 1，它三个阶段vg f是吧？
然后呢？
它呢？
是需要啊，这一个段输出之后得到这张color test ment 0，也就是这张图片作为这个的输入啊，作为一个sub pass 1的输入。
那么，通常情况下呢，我们就需要啊，这样子输入，然后计算，然后写出啊，写出之后呢，再把它送到下一个pass下一个pass的话呢，再VS gs fs这样的执行对吧？
通常是这样子。
那么，这样的话呢？
速率呃，执行的效率就非常慢啊，我们都知道gpu呢是并行的一个啊，硬件结构，所以说这样的串型就显得很笨OK，我们看一下这边。
这边的话呢，我们说啊，双方应该是同时并行开口的啊，第一个pass VS gs fs，然后出对吧？
第二个pass呢，也可以跟它一起执行VS gs，为什么可以这样呢？
因为上一个阶段的输出是一张图片，可以理解为一张纹理。
对于纹理的采用，往往啊，都会在fragment sheila里面进行啊，那么这两个阶段是处理顶点的，处理下一个阶段的顶点的，那么这样的话呢，对上面的输出结果呀，没有任何的依赖。
所以说啊，它就可以并行开跑，那么跑到它的gs的阶段完成之后呢？
它发现诶，我如果想进到这个fs的阶段的话，那么我需要等待什么上个阶段的这样一个图片的输出才能够呃进行下个阶段，所以说呢，它就阻塞掉了这个fragments的阶段，等待上面的结果。
我们看这样的话，执行效率就会非常高，对吧？
那我们思考一个问题啊，如果只规定了两个sub pass之间的调用过程，依赖那不就完美了吗？
什么意思呢？
我如果啊，我做一个dependency，这么样一个啊，依赖的这样一个结构体，在这个结构体里面呢，我填进去这么一些参数啊，我说啊。
这个我这么来规定呃，它俩中间会有一个依赖，那么这个依赖呢？
它向上连接的是这个pass，向下连接的是这个pass，那么它俩之间依赖的内存啊，依赖或者说它们俩之间啊，依赖的阶段是什么样呢？
说上一个阶段的f11段的末尾。
那么，作为呃，就是它上一个fragment结束之后啊，才允许开启下一个阶段fragment shader的开头啊，就它的末尾结束之后才允许它开头OK，那么单纯的这样去。
规定两个saul pass之间的调用过程，那就完美了嘛，那就可以了嘛啊，其实啊，是完全不完美的啊，为什么呢？
因为我们的力度还不够细致啊。
那么，每个shader stage都会有很多的操作，比如fragment shader在这个stage里面，我们就有它读入的操作，也有它写作操作读入呢，那就是读入一些文理啊等等，这些资源那么写入呢写出呢，那就是说啊，可能它要输出好多张的color attachment。
那如果说上一个saber pass没有写入完毕，那下面就开始了，那就机器了对吧？
因为你指定的说我下一个pass的fs需要等待上一个pass的fs结束。
啊，那么上一个pass所谓sfs结束结束的话呢？
那是什么意思？
对不对？
它里面有什么样细致的操作？
换句话说，就是如果啊，上一个pass不是写入，而是说上一个pass是读，那么下一个pass等待它读读入完毕啊，再使用这个资源进行写出。
怎么办呢？
okay，那么这边的话给大家啊，整理一个结果是这样的呃，我们需要规定，那我们需要向这个gpu啊，提供如下的一些问题的答案啊。
另一个pass就是第二个pass，等待上一个pass的设定的stage的什么操作完毕呢？
比如说上一个操作啊，上一个pass，它写入完毕，我才能开始执行，还是说上一个pass读取某些资源完毕，我才能开始执行呢？
那么，另一个萨罗哈斯设定的stage什么什么操作的阻塞呢？
就是说我下一个呃stage下一个pass的哪一个stage的什么操作需要停止下来等待它呢？
OK，我们看一看这个总结的知识点啊，每两个sub pass之间的依赖都要设置两组数据啊，这样会更清晰，首先啊，一个叫做source pass stage，一个叫做sa as access，它规定了什么呢？
它规定了上一个s aas pass的，哪一个stage的，哪一个操作完成后？
后我才能执行那这个des pass配置和des pass呢，是说下一个sub pass阻塞在哪一个阶段的，哪一个操作？
啊，哪一个阶段的操作的开端就停住了OK，这样的话我们就非常清晰了，对不对？
好，接下来我们要想一想啊，这里面牵扯到一个概念，就是内存同步问题，两个萨博帕斯在资源交接的时候发生了什么？
也就是说啊，这样一个等待的过程，为什么那么的必要，为什么那么的必要，因为有的同学啊，问一个问题啊，刚才说的那句话是不是感觉有点问题？
比如说呢，我说啊嗯，上一个阶段它的fragment shader写出完毕啊，下一个才能开始，那么为什么要特殊规定这个写出完毕呢？
那其实我们就需要仔细的看一看啊，这两个pass之间的一个在地皮上发生的事情。
好内存同步，我们先解释一下这个概念啊，在gpu当中存在多个流水线的运算单元，叫做stream multiprocessor，叫简称SM啊，那么类似CPU，每个SM都拥有自己的control unit，就是它的运算单元。
那么呃，每个SM呢？
还有自己的存储啊，叫做多级缓存架构是吧？
它有自己的寄存器，有l0l1l2等cash，那肯定是从这儿往这儿逐渐的速度会变慢，对吧？
那么上一个sabo pass执行完毕的结果，它肯定就存在了上一个pass所运行的那个。
SM当中。
那么，必须完全同步储存当中之后啊，那么才可以被另一个SM的流水线看到，为什么呢？
因为我们讲它是并行的，那么sub cast 0它是跑在一个SM上，sub cast 1是跑在另外一个SM上。
那么，萨瓦帕斯零处理完的结果肯定在SM 0的，他们的cash当中对吧？
那么，萨瓦帕斯一肯定要等待它同步到储存之后才能看到，所以过程如下。
ask零把它的结果写出到它自己的cash里面啊SM 0 cash，然后呢，这是公共储存OK，那么被同步到公共储存之后才会变成available，那么这张attachment啊，这张图片就变成了available。
呃，要到之后呢？
还有一个过程是什么呀？
叫做layout自动转换啊，为什么会有这个过程呢？
我们之前讲过啊，每一个stub bop ASS，它在输入图片之前，它都会对这个输入的图片有一个格式上的要求。
那么，如果萨博帕斯零输出的图片和萨博帕斯一输入的图片之间，它的格式layout不一样的话，那中间呢，就会被插一道啊，格式的转换这个是一个自动的格式转换。
那么，当格式转换完毕之后，它就变成了maz able，是对谁来说maz able呢？
是对于saber pass 1来说的OK，这个应该是saber pass 1啊，我们修改一下。
OK啊，再修改一下啊，这不是s ava hus 1，那么它对s ava hus 1v代保之后就会被读入到smeg当中，对吧？
然后s ava hus 1进行使用啊，所以说呢，这一整套的过程啊，就必须把规定的非常的这个仔细啊，所以才会用到我们刚才所说的这个。
啊，这两个这两个东西啊，这四个东西我们都要给它设置清楚OK，那么讲完这些东西之后，我们来总结一下。
我们在运行多个saber pass之间设置好彼此的依赖关系啊，那么一个是运行的stage依赖，一个是在stage内操作的依赖啊，到底是这个stage的哪个操作会被依赖到OK？
那么，点完这些内容之后呢？
我们啊，更加详细的内容需要在程序里才能看到。

