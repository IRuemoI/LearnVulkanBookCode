10-03.Vulkan-内存屏障理论

好，各位同学大家好，那课我们进行代码操作之前先讲讲barrier屏障，这barrier在很多我们的基础体系当中都会出现这个词。
包括说像我们CPU的乱序执行CPU的乱序执行呢，它大概就是说虽然说我写的代码是先做a再做b再做c，但是呢，如果彼此之间没有一个很强的关联，那么我也可以先做c再做a后做b。
那么，为了保证这条代码是顺序执行的，且在多线程下啊，能做相应的保护，我们的CPU呢，也会有相应的汇编指令去，类似于这种area的作用。
啊，它能够保证上面的指令，指令关闭之后啊，下面的指令才会执行OK，我们看一下。
那么，在gpu当中啊，乱序执行是非常非常常见的一个东西，比如说在open当中啊，那么指令录入到command buffer后，虽然启动执行方面啊，大家注意听，仔细听，在这边啊，启动执行方面，虽然隐含着顺序的启动。
但是一开始执行就无法保证相互之间的顺序了，这句话怎么理解？
那么我们想啊，在command buffer录入的时候，我们是不是一个线性的过程啊？
我们先绑定，比如说pipeline，然后定我text buffer，然后我们执行这个draw index的命令。
啊，这些命令呢？
它在我们的gpu端都会这样顺序的开启，但是当一个命令它开跑之后，谁跑的快谁跑的慢，哎，可能在后面的指令跑着跑着，比前面的快了。
前面的成果还没出来呢，后面哎，利用这个成果的程序都已经跑完了，所以说一旦开始执行啊，它就没办法保证相互之间顺序了。
我们看一下屏障，它就是指啊，在两个值之间，我们可以做一个屏障，一个barrier，我们告诉gpu一个什么事呢，就说呀。
上面的指令啊，可能是说有一个很重要的阶段，是a阶段，那么在a阶段的小a操作完成之后啊，那么哎呀，就这样说啊a阶段的a操作。
必须在这个b阶段的b操作小b操作之后才能执行啊，应该是这样子，也就是说呢，这个小b操作完毕之后啊，这边小a操作才能开始做。
这个意思，那么这个就是屏障的作用，关于这个在gpu端的屏障啊，有三种vk memory barrier vk memory buffer barrier vk image buffer barrier。
我们在这套课程当中啊，咱们先做一个入门，咱们拿什么来入门呢？
咱们拿这个Vicky image buffer memory and barrier来做入门，因为这个呀是最显而易见的，最容易这样理解的，而且也是我们这节课呢，来书写程序啊，所必须的。
OK，在此之前，我们先看一看啊，pipelines s。
我们其实在以前的课程当中呢，我们是见过这个东西的，对吧？
在哪呢？
在这个sub house互相之间的dependence是依赖啊，这节课那么我们在这呢，去仔细的看一下这个public ag is到底是怎么回事？
这个地方呢，大家仔细听啊，看我们执行任何command的时候啊，我们有很多种种类的啊，比如说呢，有一种command，它是用来做graphic操作的，也就是说渲染绘图操作。
那么还有一种呢？
它是做compute作用的啊，就是这个compute share的作用，compute share呢，我们在这套系呃课程当中啊，我们还不会涉及，然后在后续的课程当中会给大家奖励。
那么还有一种呢，是transfer transfer呢，我们之前也讲过啊，在这个sub pass当中啊，那么在sub pass当中，大家知道有一张图片，它输入的时候呢，是一个undefined这么一种layout。
但是呢，我们需要让它成为一个什么呀啊，一个optimal类型的对吧啊，一个一个叫做pavement optimal，就是说它适合去向上渲染像素。
就需要转换它的料子，任何关于转换，任何关于队列，所有这样一个啊，这个叫做移交操作啊，都需要用到transfer，那么这样一种队列。
那么，这种推列呢？
刚刚好啊，我们这种trans法类型的命令队列，它的所执行的功能，其实我们的graphic这种命令队列也能执行。
啊，所以说我们在这套课程当中啊，是并没有去单独列出来一个啊，这种transfer的队列的。
okay，那么我们看一看，相对应的就是这三种序列。
不管说任何一种序列，都需要用command来执行，那么command呢，就会涉及到版线的概念。
那么，管线呢？
不光是这种啊，渲染管线，它有计算管线，也有这种穿插的类型的管线。
那么，不管是哪种啊，它的口的一个stage。
都是top of pipeline，那么它的出口都是bottom of pipeline啊，这两个虚拟的stage，那么我们看左边图的时候呢，它会依次流过这几个阶段。
首先说indirect这种照的方式呢，就是把数据已经发送到了这个gpu端了啊，是command的数据，也就是说我们没必要啊，每一次都在CPU端不停的往CPU端里面com里面录制。
我们可以录制好了一个buffer，我都提前发到这个机pu端，然后我们只需要告诉你pur说哎，你这边啊，就按照那个以前记录的那个buffer，我发给你那个buffer执行就好了。
哎，然后进入一个好，我直接读到本地就好了，所以抓扣的时间非常短OK，那么这是这种绘制方式，然后呢，它进入第二个阶段。
叫vote x input我们知道啊，之前我们很多的execute对吧？
放到了一个vote x buffer里面，然后呢？
这个阶段啊，就是说CPU呢，要把这个vote x相关的数据读进来的时候了。
然后呢，下一个阶段就是把这个数据执行我的过程，然后呢，下面这一段啊后呢，到这儿啊，就要做early test。
因为我们知道两步垂直后啊，叫做图形装配，图形装配之后呢，会变成一个一个的三角形或者一条条的直线。
那么就需要做啊，这样一个剪裁裁完之后呢，把它离散啊，就是说光山画。
在这个步骤之前，光沙画就完成了，然后完成之后啊，它会进行early test，就是说在执行fragment事件之前，那么我先把那些看不见的fragment丢弃掉。
啊，就是early test，early test主要是通过深度来进行检测啊，等待啊，如果有个像素啊，有个fragment被挡住了，有很多丢弃啊，只有对前面的fragment才能通过测试。
这个early也称为early。
那么，通过之后啊，它要走到下面去了，就是fragmented啊，真正执行着色为这些fragment做成各种各样的颜色光照啊等等，都在这计算，然后呢，late test。
就如果说啊，我们没有进行early test，那么无法进行early test，它有很多种可能性。
那么，第一种可能性的话就是说啊，比如说我绘制了两个三角形，那么这两个三角呢？
第一个它的这个光栅化的速度非常快啊，都已经到了光栅化的这个这个阶段了。
结果第二个三角形啊，它还从这儿坐着，我test shield呢，那么自然而然啊，你说我会为了early test的这样一个呃，这样一个小小的优化，然后就我从这儿等你那么久吗啊，我不会等你的啊，我会直接往下跑，跑到fragment shield里面。
那你对于说另外一个三角形呢？
呃，那么它还没有有的执行对吧？
它可能刚走到这个呃，这个呃，光山化的阶段，那么这边我的fragment sheet都做完了，它那边才开始做fragment sheet。
随后，他们要在最后啊，进行一次late test，因为我们来不及做early test嘛，就做late test做一下，那么还有一种呢，是说啊，如果在fragment这个阶段呢啊，你更改了啊，更改了这个fragment呢。
呃，输出的深度值。
那么对不起，我上面也会检测到说啊，如果你在这一步啊，要对每一个fragment设定一个自己的这种深度值的话OK，那我就不做呃，都统一拿到这个list test里面去做。
好，那么做完这一系列操作之后，我们得到的这个fragment都是我们要去渲染的，所以说呢，到最后一个color开门的阶段，我就把它输出出来啊，画到每一个像素上。
好OK，在进行完所有的阶段之后啊，其实我们已经画到了我们的这个呃，我们的这个target上了啊，放到我们的free buffer上了，那么我们接下来呢，就通过s展示对吧，那么这个阶段呢，最后来个结尾的虚拟阶段叫top up up up line来去执行完了。
OK，那么我们现在略过这个点啊，略过这个，我们先讲讲这个啊，这个怎么回事呢？
比如说你现在有张图片，你这张图片呢？
它一开始是undefined这样的格式。
你呢？
想通过手动的把它转变成为一个什么呢啊？
比如说转变成为一个attachment optimal的形式啊？
color attachment optimal，那么你就需要做一个barrier对吧？
做一个barrier，然后哎，你把它这套信息啊送到一个command里面去，然后呢？
submit去执行。
并且呢，你等它执行完毕之后啊，你再做下面的渲染操作，也就是说这一步啊，是独立于我们渲染之前的啊，在render循环之前你就要去做这件事儿，把张图片啊，各种变格式啊什么的。
OK，那这时候的话呢，你所构建的这个command buffer在录制的时候其实是不用去做这个render pass skin的，对吧？
那么也就是说你跟这一堆东西都没关系了？
它呀，就会先触发一个tall of pipeline的，这么一个阶段，然后呢，会跳入transfer这个阶段啊transfer，然后transfer之后呢，会跳到bottom of pipeline啊，是这个意思？
所以说呢，我们经常转格式啊，比如说做内存的这个转换呢啊，再比如说做这个八份啊，在不同的队列之间啊，所有权的一个转换呢，我们都会走这个转换阶段。
OK，那么我们重点讲解了左边和右边啊，这边的话我们留在我们这个broken提升课本啊，提升课的时候我们再做。
好，那么我们看一看乱序执行了啊，这边的PPT还没问题，没事，我们先放在这里吧OK，我们举个例子，我们要读录一张图片，大家都知道啊，对于纹理的图片来讲，其实是给谁用的呢？
是不是在gpu上升到负面的时代的时候，去采样的时候用吧。
就采样它，然后着色到是不是我们的物体上那么那么我们就知道它并不是一个后色雷德堡类型的内存，就我不需要从CPU再访问它了，全是CPU访问它。
所以说给它放数据肯定要用到一个stage buffer好，那么我们读一张图片，通过stage buffer拷贝到week image所对应的一个内存上。
然后图片的格式啊，必须要作为这样一个呃纹理在fragment sheet上进行读取，所以我们要做一个什么呢？
做一个格式的转化。
所有转换的话，我们我们有一个规则啊，说格式转换完毕后才能进行分面的11点的输出，对吧？
那有的同学就问了，说哎呀，老师啊，你看我可不可以这么干呢啊，我直接在render之前我把这张图片转化完毕，能不能行啊，然后我再进入这个渲染循环呗，是没有什么依赖关系啊啊，是可以的。
但是啊，当图片量比较大的时候，我们还是希望它并行来做的，对吧？
那么在并行做之前，我们先看一下这个顺序执行，首先我们做格式转化，然后我们加一个barrier是吧？
在格式转换完毕之后，我们进行这个呃流程绘制。
啊，那么这边才能够采样，对吧？
这个图片那么我们就需要做一个barrier，这个barrier可以写成这样子啊，它的参数是下面这样子，它的source配置是什么呀？
是不是上一趴的这个bottom of pipeline？
就是说上面这个格式转换完全完成之后，对吧才行？
那它的目标是什么呀？
是下一次指令提交的时候啊？
top of pipeline。
大家能不能听明白这个地方？
啊，因为这边是一次命令的提交啊，一次submit这边又是一次submit，那么这一次的submit啊就需要。
完全早于咱们这次的早命好，怎么理解呢？
我们看啊，叫做顺序提交顺序开启，但是什么乱序执行对吧？
所以说你这次提交的命令啊，它是提交了，但是只要你不去等待这个队列的完成。
那么直接去提交下一个指令的话呢，那么这边的格式可能没转完，然后这边就直接开始绘制了，对吧？
直接开始用这张图片了，所以中间要加一个barrier呃，那么我们最简单的写法就是这种写法。
然后呢？
它的这个access啊，我们也讲过，说access是什么东西啊？
access是说啊，这一个阶段的某一个阶段的某一种操作，对吧？
我们看一看啊，格式转换。
那么，它其实呢？
是说把这张带有数据的图片，那么是不是要搞一个新的图片出来，用新的格式，新的layout，然后呢，把这些数据写入这个新的layout所对应的这一块内存上，对吧？
所以说呢，它会有一个写操作，我们就需要等上面这个阶段的写操作完成啊transfer right bit完成，我们才能够执行。
这一个阶段啊，下一个阶段所对应的Vicky access shadow with bit。
okay，是这个意思。
但是这个barrier它挡住的，那可是说什么呢？
那可是说两个大的啊，两个大的提交啊，那么对于第二个提交来说啊，我们看一下上面这张图啊。
我们是不是说前面这一堆操作都会等待上一次操作完成啊？
前面这一堆一直到framing为止的这一堆操作也都要跟着它一块去等待格式转换完毕。
啊，那么这样的话，效率就很低，我们的流水线就流不起来了。
那么我们现在看一下啊，命名的乱序执行怎么回事？
我们看这边呢，都是我们的关于格式转换的，这次操作格式转换的，这次操作呢，我提交了一个command buffer，那么它也会触发这么几个stage。
首先有个虚拟的staged OOF pipeline，然后呢，开始转换进入transfer这个stage，转换完毕之后呢，进到bottom of pipeline OK，这个是非常简单的一次指令提交。
这边儿呢，就是我们绘制指令的提交，首先top of pipeline，然后顺序依次流过每一个阶段，最后到达bottom of pipeline，这个是我们绘制里的带有render pass begin这么一个可玩的打法。
supplement之后啊，进行了一堆操作OK，那么我们现在使用一个barrier，我们只需要让这两个流程之间产生依赖即可，对吧？
然后呢？
上面绿色的部分其实都与这个转换是没有任何关系的OK，那么我们就可以这样去写这个barrier了啊，这个barrier是这样的，它的source stage啊，那么我等待上一个阶段的哪个stage呢？
我等待这个。
啊，transfer stage完成，那么我的desk stage是什么呢？
其实我在等待的是啊，这个fragment sheet的开始。
然后呢？
source access也就是说我需要等待这一个阶段的什么速度完成呢？
是它的transfer right bit完成。
啊，就是说格式写入完毕，那么这个图片的内存就可以用了，对吧？
就对我们可见了，然后呢？
我哪这一个阶段的哪一个操作在等待看到是access shader read bit。
啊，就是说在读这个操作这等等。
OK，那么这个就是这样一个barrier的案例啊，我们用它来进行分析好，那么我们这节课先讲到这里，我们后面呢，就开始去制作这样一个程序来看一看到底是怎么回事？

