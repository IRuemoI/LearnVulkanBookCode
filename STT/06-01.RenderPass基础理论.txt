06-01.Vulkan-RenderPass基础理论

我们这节课呢，是进入render pass这个部分的学习啊，我们首先来看一看render pass与它的sub pass这两个概念。
首先啊，render pass呢是每一次提交包括命令之后啊，要输出到一张或者多张图片的结果，对吧？
那么这个过程就称为一个render pass。
啊，那么有人的pass呢？
主要描述了啊，这个pass当中它的输入和输出相关的信息就是你输入，比如说一张什么样的纹理，一张什么样的图片啊，作为input test ment，然后你输出一个，比如说你输出的是一张画面啊，或者是说你把颜色信息。
啊，分别输出在了三张不同的图片上啊，那么描述这个过程呢，就是人的pass。
那挖盘当中呢，可以创建其对象，就需要人单pass这么一个对象，主要描述了pass当中输入输出OK第2 sub，因为我们啊，在渲染当中存在很多方式啊，需要多次的pass才能够渲染得到最后的结果啊，举个例子。
第1 pass先渲染一张图片啊，就是比如说我们正常渲染吧，一个三角形或者一个模型啊，然后呢，把这张图片作为纹理输送到下一个pass里边。
然后在第二个part里面呢，对图片上的像素进行采样，然后进行卷积运算，然后再将其图片中的边缘高光啊，这个这样子我们就得到了一个什么呢外圆轮廓啊，或者是说边缘轮廓被高光画的这么一张图片。
那么，两个过程就是两个sub pass，它们可以在创建一个render pass的时候啊，我们可以给其加多个sub pass这样子。
那么，接下来大家说一说啊，这个render pass的附着，这叫attachment，每一个pass它都要有渲染后输出的画布，对吧？
比如这一盘，我们啊，可能要渲染输出一张图呃，两张图啊，把物料信息输在一张图。
把每一个啊小方格，每一个像素格的这个now信息就把信息输到另外一张图，那么每一张图啊，它都称为一个test ment。
那么attachment分两种啊，第一种是叫做color attachment，就每一个pass负责承载啊，承接颜色输出的画布，那么一个pass我们刚才讲了，可以有多个color attachment分别输出不同的颜色信息。
那么有的同学说啊，这个你刚才说把法线也能够输出到画布上吗？
啊，是可以的，为什么呢？
因为颜色啊，我们正常的画布上面一个像素是rgb a对吧？
那么法线来讲呢，它也可以把xy bz理解成为rgb对吧？
同样是flow的信息啊，然后可以输出出去。
那这样子，那么第二种啊，叫做defs stential attachment就是深度模板的一个附着，那么每一个pass啊，他们都可以承负责承接深度模板信息输出的画布，那么这个画布啊，它就叫做。
这个深度模板附着啊，那么什么是深度信息？
什么是模板信息？
我们一会再那么一个pass，只能有一个啊，只能有一个此类型的attachment。
OK，那么我们看一看啊depths tanti al attachment，这是个什么东西啊？
呃，首先深度信息，那么对于屏幕上每一个像素都有可能输出多个物体的fragment。
对吧，你比如说咱们之前经常举的例子，先画背景，背景前面画一个人是前面画了条狗，对吧？
那么也就是说呢，总有那么几个啊，或者是多个像素，那么这些像素呢，它们是被有有三个物体都向其输入了像素的颜色。
那么，我们就需要知道谁在前，谁在后，能够确定彼此之间的遮挡信息。
如果我先画了人，再画了背景，如果没有这些啊，深度信息的判断的话呢，那么这个背景反而会把人挡住，对吧？
因为我先画了，再画了背景。
那么，描描述起来是这样子的，所谓深度啊stench深度辅助啊，我们看其中的深度信息，它其实就是一张图片，我们呢，其实就是在一个人的pass里面啊，指定说啊，你这个人的pass，它里面的深度信息，请输出到这张图片上。
那么，这个图片初始的样子是什么样呢？
就是这样子，它们每一个呢？
都是上面都写着max，它是最大值那么一般情况下呢？
它的最大值都是一点零啊，因为我们的深度一般情况下都是零到一啊，零到一的，这么一个深度。
会被归一成ndc ndc，再转化到零到一啊，这样子那么这个深度信息呢？
怎么输出呢？
第一个物体绘制后啊，会更新相关区域的深度信息，我们看我们绘制了这么一个形状啊，然后呢，它输出那么每一个像素上都写着它当前的深度信息。
也就是说这个这个物体啊，它在这个每这个像素上是零点五的深度啊，那么在这是零点三的深度就是一啊，在这边零点六的深度证明零点六零点二点三OK第三步啊，在绘制第二个物体的时候会用其深度与当前值进行对比。
如果它的深度比当前值小，那意味着什么呢？
它的深度小说明它的z就小z小，那么说明什么？
它离我们的眼睛就近啊，离我们的画布就近，那自然而然它就应该画在前面，那如果说它不比我们当前的小，那么就会进行丢弃。
OK啊，比如说像这样子啊，零点五零点六零点六，如果对面都是零点四对吧？
新画的物体都是零点四，是不是这三个方格就会被啊？
就会被替代掉，就变成这样子了，然后呢？
它会把这个当前啊，这个深度图上的信息更新成比较小的这个深度。
零点四零点四零点四对吧？
那如果说它这儿还有的话啊，零点四比零点三要大，那它就不能去更新这边的深度信息，因为当前离我们最近的这个这个图数呢，是零点三的深度啊，这个道理。
那我们看这样经过一轮一轮的绘制之后呢？
那么这张图片上就保存着啊，当前每一个像素格啊，距离我们最近的那个物体的啊，像素的什么呢的深度值对吧？
也就是说当前每一个像素上啊，所有物体对比来看最小的那个深度值就被绘制上了。
那么大家就这个地方啊，要仔细观看一下啊，仔细的细细琢磨琢磨。
那么，接下来我们再看一看什么叫做模板信息，它对于屏幕上每一个像素都可以通过渲染一个物体，针对其覆盖的区域输出模板参数，再针对模板参数进行绘制。
那么，这个听起来还是不怎么好，明白啊，我们选择多种运算方式中的其中一种，举个例子。
我们看模板，我们也把模板理解成为一张图啊，每一个像素格上都有一个数字，对吧？
初始的模板呢？
它这张图呢？
都是零在渲染之后呢？
我们这样子开启模板呢？
写权限也就是允许人家pass啊能够。
对这个模板上的每一个格进行写入啊，绘制一个三角形，然后我们规定啊啊说绘制一个三角形，那么其覆盖的区域我们希望都被设置为一，也就是说呢，现在有两个附着对吧，一个附着是color附着哎，那么我们就把颜色信息输到那个color上去。
另外呢，还有一个是模板附着啊，我们就把它对应的覆盖的区域都写为一好，它就被写为一了。
那么，这个模板信息写为一之后怎么办呢？
在下一个pass里面啊，关闭模板，全模板权限模，关闭模板的写权限啊，大家注意，这是在下一个文档pass里面，或者是说下一个sub pass里面。
那么，关闭完写权限之后呢？
是下一个更大的三角形，那么绘制一个大三角形，假设这个三角形有真爱码啊，那理论上讲是不是应该被它把它给覆盖了，对吧？
假设我现在没有开启深度检测就没有用那个深度的attachment。
那么，它就应该把它给覆盖掉，对吧？
因为它这么大，但是呢，我们规定说模板唯一的地方输出的图源诶，丢掉那么也就是说它会变成这样，对吧？
你看这样一个三角形，本来应该复制整个区域的啊，覆盖整个区域，但是我们规定了说模板唯一的地方把它给抠掉。
哎，就变成这样子了，所以说呢呃，这个这个三角形啊，它只会在周边输出它相关的图源，而这个三角形内部啊，由于上一个三角形存在的原因啊，就会被怎么样啊，就会被忽略掉啊，这块儿的图素就输出不了了，所以这个就是模板的一个好玩的地方啊，它可以为任何一个物体啊生成。
一个边界线啊，一个高亮的边缘。
OK，那么一般情况深度与模板啊的attachment是在同一张图片上的，刚才我们啊是按照两张不同的图片来讲解它，那么实际上来讲呢，它经常放到同一张图上，比如说对于每一个像素而言，我们把这个像素的前24位理解成为深度信息。
那么，最后的八位理解成为模板信息啊，各写各的啊，但只是在一张图上是这个道理。
好，我们总结一下，附着分为color，附着与深度模板，附着那么同一个人的pass啊，可以有多个颜色附着，分别说出不同的含义的信息。
但是呢呃，也可以输入到下一个sa as作为输入的纹理，但是我们的深度附着呃，可以选择性的开启，但只能有一个那么下一个阶段，你可以继续沿用。
深度附着呢，通常与模板附着啊，合一用一张图片附着，创建之后绑定到render pass上，作为render pass的模板啊，这样子。
那么，我们接下来看，叫做render pass的附着索引啊，这个什么意思？
好，我们看一下附着索引啊，在创建了啊，我们都知道一个人的pass是不是可以创建多个color attachment和一个depths对吧？
所以说这句话啊，在创建了n个color attachment以及一个color attachment后。
我们呀，会把这一堆attachment都放到一个数组里面，传递给我们的render pass好，那么在一个大的render pass里面呢，会有多个小的sub pass。
在每一个sa as当中啊，就要确定使用这个数组当中的哪些附着OK，那用于描述附着的啊，它在数组当中的位置信息以及格式信息的结构都称为附着的索引。
具体来看，假设这一个render pass啊，大的render pass里面我们给到了三个啊color attachment以及一个depth center attachment。
然后呢，我们把这三个附着四个附着呀，装到了一个数组，也就是一个vector里面那么0 vector 0，是不是就这个一就是它二就是它三就是它对吧，一个数组里面？
然后呢，我们为这个大的人的pass创建了两个小的萨的pass，分别是零一。
那么附着呢，这个索引就表示什么呀？
哎，这样子也就是说呢，萨博帕斯零它所用到的颜色附着是零和一这两啊，这两个索引那这两个索引所以用过去了，以及这个大数组中的三号索引，也就是这个深度啊，什么满附着？
给它引过来，这就是唉一个索引，然后呢，在s aas pass 1里面，我们使用的是attachment啊，也就是说二号索引所对应的附着就是这个以及三号索引所对应的深度模板附着这两个附着都被它使用。
啊，所以说我们看到的这个啊color attachment reference啊，就这个附着索引reference这个结构，我们后面会看到它，其中呢，就有一个参数啊，用来指当前这个附着它的。
这个索引别号啊。
然后呢？
在其中啊，每个索引它都描述了当前附着在啊，它在当前的附着啊，在输入sub cast前应该转换成什么样的格式？
这个怎么说呢？
也就是说呀，我们这个所谓的附着索引啊，它其实不是一个int数的啊，int数值，它是一个结构体，那么这个结构体里面啊，它包括这个零一零一二三等等啊，这样一个int型的index啊int int这样一个索引。
但是呢，这个结构体里面还包含了另外一个信息啊，那就是输入到这个萨博哈斯之前，那么这两个啊色附着应该转换成怎样的格式输入进来？
好，我们看一看。
图片的格式啊，一个catchment，那么其实就是一张片，对吧？
它都有自己的存储格式啊，我们知道在gpu当中呢，有很多是啊，相对于硬件来做的优化，对于驱动做的优化。
那么我们看几个这样的图片格式，第1 ap image layout undefined就是不关心及格啊，输入之后会一抹抹掉它的数据。
不关心它的这个上一呃，不关心它原始的数据对吧？
也就是说无所谓的一个格式，第二个叫做color attachment optimal对啊，color attachment optimal，也就是说使用这种格式的图片呢？
它是适合颜色附着的优化格式啊？
我们看到叫optimal就知道唉，其实它是挺呃，不太好不太好人来读识别的啊，不太好人类来阅读的这样一种格式，但是呢，特别适合机器阅读的格式啊，速度会很高，那么第三种defs ten SIL它是我们optimal，也就是适合深度模板的附着的，唉，这种大格式啊。
输入输入的这样一个输出深度的信息，以及啊，这个温度模板的测试对吧？
这样一个过程都特别适合这样的格式的图片来来来做啊，所以说呢，每个萨博帕斯啊，他对于附着啊都有自己的要求。
那么，进入到本萨瓦帕斯之前，malkin呢？
就会做一次隐性的图片转换，相当于插入了一个Vicky barrier啊！
这个概念我们后面会讲啊！
也就是说，我们看。
比如说这两张图片，它一开始呢，是刚创建的时候啊，会一个undefined这么一个形式啊，这么一个格式，那么在输入到萨博哈斯零之前。
啊，那么中间呢，会有一个阶段就是图片格式转换的一个隐性阶段，它们呢，它们两个就会被转换成为啊，一个link image layout呃，color attachment optimal这么一种格式诶，然后转换完了再输入到这个sa as 0再进行渲染。
所以说是这个道理啊。
okay，那么关于rand pass啊，这个理论就讲到这里。

