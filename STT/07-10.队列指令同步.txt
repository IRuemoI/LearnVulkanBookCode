大家好，我们这节课来解决最后绘制的最后一公里问题，这个问题是什么呢？上节课给大家展示过我们的 command buffer，在被提交之后它就会去执行，对吧？那么这个 command buffer 还没有被执行完，结果又刷了 3 帧，又轮到它去提交了，也就是说提交了一个执行中的buffer，这件事是不允许的，除非我们做之前讲过的那个设定，对吧？但是在这里我们对它进行一定的控制，我们用什么控制呢？就叫做Fence， FENCE 这个东西，那么 fence 我们是把这个东西构造完之后传入到哪里呢？大家看这里有一个 q submit，对吧？这个指令它这个地方我们设的是空，现在我们就可以给它一个 fence 了，告诉它说你这一次提交的这些东西，不管你提交了多少个指令，不管你做了多少个，是吧？这个是多少个submit？我都等待你这一通东西在这个队列上执行完毕之后。那么我才把这个 fence 给点亮，否则这个 fence 就是非激发的状态。

OK，那么我们接下来就包装这个 fence 这个类型， fence h，这边是 fence CPP。好，先拿一个帽子来，这么多哈，OK，好，然后把这几个东西都删掉。

class fence public break。

我们把 Fence 相关的介绍写在这里，首先 Fence 是控制一次提队列提交的信号量，这个跟 Semaphore 的感觉就很像了，但是 Semaphore 我先把区别是写在这里与Semaphore。我们就不要叫它信号量了，我们把它作为标志啊。

那么与 Semaphore 的区别在于哪呢？那么 Semaphore 控制单一渲染管线内的，或者说单一命令，命令这个提交信息内的不同执行阶段之间的依赖关系，对吧？而 Fence 控制的是。队列，就是说一个队列，比如 graphics queue 里面提交的所有，就是里面怎么说呢？一次性提交的所有指令执行完毕，它是控制这个，对吧？那么 Fence 分为就是激发态以及非激发态，并且可以进行 API 级别的控制，那么它这个 Semaphore 是没办法去控制的， Semaphore 是没是无法手动用 API 去这个激发的，那么但是这个 3 FENCE 可以通过 API 去给它激发掉这个意思。好，那么我们现在把 fence 去写一下，首先构造函数fence，析构函数fence，然后我们还是把帽子直接拷过来，这样比较舒服，节省时间。

好，那么肯定，对吧？对于这样一个构造的话，我们也是需要传入 device 的，那么除了 device 之外，我们还可以传一个参数叫做布尔 signal NODE，这个代表什么呢？代表着它一开始被构建出来的时候，它还是非激发态好，那么接下来再把它家属也给它给到 create 里面默认激发的状态这边默认激发的状态 signal NODE 同样传进来。好，这个帽子我们写完了啊。然后走到private，这在 Vulkan 里面，它叫做 VkFence 这么个结构没有提示我们要先把它加到我们的编译队列。 VK Fence 好诶，还需要生成一下缓存好它就过来了。这个 VK Fence 就是 Fence 在 Vulkan 里面的句柄对象，称之为 m Fence VK now handle。然后它肯定要跟 device 相关喽？ device 好。

既然如此的话，我们能够手动控制它的激发和非激发，那这样的话肯定有两个函数，一个是 reset fence，这个是将其置为非激发态，就是把它变成一个非激发的状态。然后另外我们还有一个函数 we can block 是什么意思呢？这个地方就是调用此函数，如果 Fence 没有被激发，那么就，那么就阻塞在这里等待激发。这么个意思，阻塞在这里等待激发，好，那么这是Fence，那么在 Fence 里面我们接下来就要去实现一下它的这个各类函数， fence 点CPP。

分子构造函数，它的构造函数，我们把它的这一堆东西抄过来。好，首先 m device 等于device，那么接下来构造一个分子一定需要它的 VK fence create infer，是吧？ create infer。对。好， create infer as type 等于 vk buffer type fence create infer。

好，那接下来我们还要设定它的flags，这个 flags 是代表什么东西啊？代表着它是否被激发，我们就看它你是否是激发，如果你是激发的话，我们就是 vkfence 叫 createvkfencecreate 信号的就是已经被激发了，否则就是不被激发的，就是0。好，非常简单，然后这边我就去 create 就可以了。如果vkcreatefence，那么第一个 device get，第二个 info create info，第三个是nowpr，就是默认分配器，然后第四个是 m fence，如果不等于。 VK 对 VK success 的话说明什么呢？ throw 对吧？ SD run time error failed to create fence 好，很简单，这样我们的 Fence 就创建好了。

接下来在析构函数，同样，如果 m fence 不等于 we can now handle 的情况下，我们再去析构 destroy Fence device，然后是Fence，最后是一个默认分配器，OK，好，这就是 Fence 啊。然后接下来我们要写它的接口，第一个接 avoid reset fence，将它置为非激发状态，它被某些比如说我们的队列执行完毕了，是吧？那它就激发掉了，这个就通过之后，那么我们在下一次一定要先把它置为非激发态再使用它，就是叫做。

wait a reset Fence 这个首先 device get device 参数是多少个一个，对吧？第三个是哪一个？ Fence 直接给它置为一个非激发的状态，那么我们还有一个函数是 Fence block，就是等待它，等待它被激发的这么一个函数就阻塞在这。那什么呢？叫做 wait fence wait for fence m device get device 第二个参数是等待一个，然后等待哪个fence？等待这个fence，然后等它多长时间？等它 fence wait all，还有 wait all 是true，就说我这一堆这个指令都在等待，然后 timeout 的话就是叫做。

OK，这边 timeout 其实我们是可以设置成为一个参数的，对吧？我们让它成一个参数，就是我们传进来它 timeout 的时间，就是我最多等你多久？ INT 64 杠 T 这边有一个timeout，我们可以这么用，这样我们把它拿到后面来，这样，ok，看一看out，那这里有个错啊，我们这参数刚才写错了，看看count， count 之后应该就是FIN，等待哪个FIN？等待这个FIN，是吧？然后给它加一个去用。

好，那这样的话 block 我们也做好了，这样一堆 face 我们都做好了，然后我们再去到 application 里面，同样给每一帧都要搞一个 face SDD letter rapper face r m faces 啊。好，我们还是去到 initwalk 里面，这个函数在这里。嗯，好长，再都关一下这里，对于每一个我们都要生成一个 face 在这里 auto face 等于 rapper face create 传一个参数device，然后默认是true，是吧？默认是激发态，然后 m faces push back face。

好， fence 我们也创建完毕了，装到这个数组里面，接下来我们去使用它，在 render 里面使用这个 fence 的话，我们只需要改一些地方就可以了。好，那么在开头的时候，我们在获取之前，那么我们应该先去从这里等待上一个 command buffer 执行完毕，不是，上一个是在等待当前要提交的 framebuffer 执行完毕，对吧？那么等待谁呢？那就应该等待它 VK wait 叫做 for fence，诶，这样子，对吧？但是我们不是用它的，我们是用 m 叫做fences，它的 DM current frame 的。

block 就可以了，除了等待，因为一开始的时候这个 facades 它是已经被激发的状态，这里还有一个空。OK，那么我们让它处理一下，我们呢？我们让它等于那个 int 六十四的 INT 64 的 max 就可以了。等一个默认值，然后我们再回到 application 这边 block 住，来，再来一下block，嗯。这里是参数太少，ok，写错地方应该写到它的。声明的地方这里好，还是回到我们的 APP location，在这里 block 指出之后，他就会把当前这个，就是说他的上一帧，就当前这帧的这个任务执行完毕。

current frame，因为 frame 是在最后会加一对吧？然后做一次百分比的运算，然后到这里我要进行这一帧的操作了，这一帧所对应的 command buffer 的操作，所以说就 block 住它，然后 block 住之后，我们在提交命令之前，就这一步之前我们要做一件事什么呢？ m fence current 把它给 reset 一下，就变成非激发状态，之后我们就要。这一步上这边给他传进去了，OK， get fence 还没有这个接口，补一下， fence no discor auto get fence RM fence。

好，这边我们调用 get fence 给它传进去，传进去之后这样我们整个流程应该就顺畅多了，我们再看一看啊。好，这样正常显示 validation 列也不会有任何报错，但是在我们关闭的时候，大家看就会报错，是吧？他说什么呢？他说你要去毁掉一个 command pool，并且这个 command 正在被执行。为什么呢？是因为我们在这个 Loop 的时候，直接退出来就整程序就挂了，但是在这个退出来之后， GPU 那边可能命令还在被执行。所以说我们应该在这个地方加一句话，就 wait for q 这句话。句话应该叫做 wait device，然后 wait idle 就是等待空闲，我们等待谁空闲，我们等待这个device。 get device 就是说这个 device 它所有的任务队列里面的东西，不管显示也好，绘图也好，你都结束掉，我们再退出再清理，这个意思好，我们再跑一遍，OK， resolution layer 没有报错，然后我们关掉哦。

好，关掉之后也不会有任何的错误，是吧？在这边给大家留一个思考题，这个思考题也比较有意思，那么这个思考题是这样的，你看这边我们是用的这个 frame block 数，对吧？然后但是我们提交命令的时候，我们看一看在这个地方，来，在这里我们提交命令的时候是 image index，对吧？那这两个量之间的关系就很有意思了，就说这个 image index 和 current frame。这边有没有可能它的 image index 并不按照 0123 的方式给到咱们呢？那如果不是按这个 0123 的顺序给到咱们是乱序给过来的，那么我们又该如何处理呢？这边我们留个思考题。好，那这节课我们就讲到这里。

