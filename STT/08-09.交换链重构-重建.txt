各位同学大家好，我们上节课已经这么一个小框架，就是 request sub chain 这方面的东西，那么我们已经做完了关于它的clean，那么 clean 完之后的话一定要开始重建，对吧？重建这件事情就非常简单，我们只需要走到这个 init 里面，从 SUB chain 开始，下面的这一堆给它放过来，然后把该取消的取消掉。

我们看一看 SUB chain 重建，重新获取长宽没有问题，然后这边关于 render pass 没有问题， frame buffer 没有问题，创建模型删除掉也不需要了。 pipeline 没有问题，这个我们也并没有去把它取消，然后重建一下 command 没有问题。填充重建这个 semaphore 和 fences 没有问题。

好，那么这边的话我们重建就写完了，那么接下来我们要看什么时机去使用它？在此之前我们先用这个 window 走到这边，我们来记录一下，我们来手动记录一下这个window，它发生变化的时候，发生变化的时机，那么为什么要这么干？因为它这个 Vulkan 它虽然可以对 window 的变化做出反应，但是目前还没有这么稳定，所以在这也要做出一些判断，加一些标志位，这标志位我们就把它到这里都有 public 的标志位，因为这样会比较简单，我们如果自己做引擎的封装，那这块一定要封装比较好，布尔得到window。 resizefalse OK，那么我们什么时候才能把它制成 true 呢？那么一定是我们窗体发生变化的时候，它才会变成true，所以我们在窗体这边要做一个回调函数static，那么 void 叫做 window resize 这样一个回调函数，它返回的是什么呢？是glfw、window，还有它最新的长宽，最新的这个宽高， int 宽度， int 高度。

OK，那么我们现在遇到一个问题，这是一个 static 的函数，它这里面我根本就无法拿到我们当前这个 window 的指针，对吧？那么也就无法去把我们的标志位变成 true 了，那这种情况下我们就需要按部就班的一步步去做，我们看一看怎么用 GLFW 向这个回调函数传入我们这个类指针呢。

我们可以这么做， glfw set window user pointer，我们可以用这个函数来做，也就是说在window，我们当前这个 m window 所指向的对象上面，我们挂上一个什么呢？挂上this，这样的话这个 this 会变成一个 user pointer，变成一个用户对象被塞到这个 window 所指向对象的里面的变量，它里面有一个变量是专门给我们用来传数据的这个意思，然后我们设置一下回调 glfw set frame buffer， resize callback，第一个传入的是win，给这个窗口去设置，第二个是callback，那么就是 window resize。好，那么我们这边就设置完毕了。随后我们把这个打开，把它变成true，允许我们窗体发生大小的变化。

好，那么我们现在回到这之后，我们要先把传入的这个类似指针这个数据拿出来， auto p user data，那等于应该是叫做 GFW get window u pointer 这个函数，我们传入window，这样我们就拿到了这个指针，但是我们拿到的指针是个什么呢？是个 void 星，因为这个传入的就是个 void 星，会被强转成 void 星，所以说我们要把它做一个转换，那么就用 reinterpret cast 把它变化成为我们的 window 星。

这样才能够算真正的拿到这个数据，这个是重新点示当前指针所指向的内存块，重新点示它的意思，OK，那么我们把它的 resides 变成true，哎，这样就合理了，对不对？好，我们现在在 window 里面也记录了这个标志位，那么我们接下来看一下触发的时机，就是说我们重建交换链到底在什么地方去做啊？我们回到application，然后我们去看一看这个render，在这个地方有两个时机点，第一个时机点是获取到一张可用的 image 的时候，那么第二个时机点是去推向这个显示引擎的时候，我们先看第一个时机点，其实这个函数会返回一个。

vk result。好，那么我们就来判断一下它，来决定是否要重建计划链，我们先把它清理一下整体，然后重新生成一下。好，嗯，在这边我们来写一下，如果 result 它等于了 VK 叫做 error out of date，那么这个意思就是说你确实需要重建计划链了，因为你窗体发生了变化，发生了尺寸变化，所以需要重建这么个意思。在这边我们直接调用recreateoption，并且由于它窗体发生变化，所以说我们那个标志位刚才那个也可能会发生变化，对吧？所以说window。所指向的这个标志位，我们要给变成false，因为刚才已经被搞成 true 了。

else 如果 result 它不等于 VK success，因为它除了等于这个之外，还可能等于个 VK success，对吧？所以说如果 result 它不等于 VK success 的时候，我们是不是就应该抛异常了，对吧？但是在这个地方还有一个参数，我们也要把它给判断一下，不等于VK，叫做 SUB optimal HR，这个什么意思呢？这个是指我写在这里叫做得到了一张认为可用的。

属性，但是表面格式不一定匹配就不能完美匹配，所以说这种情况也是可以忍受的，要么你给我成功，要么你给我张图，你要啥都做不到的话，我就 throw new runtimeerror error failed to acquire nextimage OK，那么这是一个时机，那么我们看一下另外一个时机点，在这边也是通过 result 来获取的，在这边如果 result 就是等于了vkerroroutofdate。那么肯定要做一次交换链的重置或者result，如果等于了 VK SUB。 Optimal KX 那么也要做重置啊。

上面说了，我搞到了一张这个表面格式并匹配的图片，但是我可以去用，那么我用了之后发现果然不匹配，对吧？又出来了，所以说要重置了，但是由于驱动程序就是说不一定精准，所以我们还需要用自己的标志位判断，就是那个window，对吧？那个 window 它是一定可以在发生尺寸变化的时候把它给变成 true 的，所以说即便是有的时候我们得不到这两个结果，我们也可以通过什么来判断呢？通过window，通过它来判断，OK，那么一旦符合这几种情况，那么我们就要 regret surface。并且在做完之后需要把它变成false，那么其他情况我们得看一看，如果不等于上面的情况，我们再看看是否是等于success，如果它连 success 都不行的话，我们就只能干throw。是不是 FB runtimeerror failed to visit？OK，那么做完这一系列的操作应该就可以了，那么我们现在实验一下。

好，我们看。诶，大小变化是吧？没有问题，再看这边纵面也没有问题，关掉也没有问题。好，我们现在要处理一下关于这个最小化的问题，我们知道这个重建交换链一旦说触发了这个尺寸的变化，那么它一定会去到哪里？它是不是一定会去到？ requestshow 窗这边，对吧？那么我们俩重建之前，我们一定要判断一下它到底是不是最小化了？如果你最小化之后，我们这些工作就不着急执行，我就从这等着你什么时候把这窗体放大了，我再给你弄。

那么我们这边怎么判断呢？我们就把这个窗体的大小先获取到，好，我们做一个宽度和高度，在这边我们获取一下 get frame buffer size，获取目前窗体的大小，还有window， get window，然后把这个宽度和高度去给它获取到。

好，获取到之后我们要开始判断了，做一个循环，不停的循环，去看一看，如果它等于 0 或者hit，也或者 hit 等于的情况下，那么就要进入一个等待的过程。怎么说呢？就这样子加 waitinwait 去等待事件的发生，那么有任何一个事件发生，比如说用鼠标点了一下，它是不是放大了？再比如说或者其他的事件，反正只要是导致尺寸变化的，你只要是事件就一定会先要导致尺寸变化，把这窗体给我弹，你才能够再继续，对吧？所以说只要接到个事件之后马上要干什么呀？马上要再获取一下。

看它的尺寸到底对不对？如果上来发现尺寸又有可能为0，那么这边还得要等待，还得在这等待，卡在这，对吧？好，那么我们再跑一跑，看一看这个最小化的情况是否成立。好，我们窗体最大，再缩回来最小化，等待进入，等待之后我们看一下是否在这等待着啊。好，已经卡在这了，我们就弄在这，然后把它放回来。哎，你看我们想把它放回来的时候，刚才我点击了这窗体，刚才点击了窗体想把它再放大，它就发现它就从这到下面了，它获取下，那么它发现宽度、高度仍然为0，再走，当它发现 800600 这个的时候就开始这个意思，然后 F5 继续跑起来，回来了最小化。最大化，然后再伸缩一下，没有问题，关掉。我们再看一看 connection 链没有报错。好，那么就比较完美了。好，那么就到这里。

