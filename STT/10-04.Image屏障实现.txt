10-04.Vulkan-Image屏障实现

各位同学大家好，我们上节课呢，给大家演了关于image upper barrier这样一个东西，它呢，是用来在同步同一个队列当中的上方的操作与下方的操作啊，在内存当中的这么一个同步关系。
那么，我们接下来呢，就开始在我们原来的这套代码里面啊，去实现一下这个image的格式转换啊，好，我们先来啊，把我们的代码呀，稍微的更改一下，因为之前呢，我们还没有写这个create里面的参数。
我们把参数列表先给它补全一下。
把它拷过来就好了啊，然后这边我们也要把参数列表进行补全。
okay啊device。
宽度。
高度，然后f。
image type.telling usage.sample啊，看我们的这个图片还有很多的参数啊couples。
然后是aspect flex啊OK，其实这样写呢就非常的清晰，对吧？
这种参数的这样一个写法格式啊，也希望大家可以利用到好，那么做完这些东西之后呢？
我们简略做一下分析啊，一个分析。
如果我们需要做一张被用于什么呢？
纹理采样的图片，那么啊，我们首先需要。
安培放映的。
layout.变换成为变呢transfer dest不是说呢，我们首先从把这个图片啊变成一个可被传输的啊，可被复制的成为一个目的地，对吧？
因为有stilling buffer嘛，到时候。
然后呢？
在啊，这个数据拷贝完毕之后再转换成为。
only对吧，就变成一个可采样的这么一张图片啊，11点儿only这样的一个优化的格式。
OK，那么我们接下来呢，就可以去写一个函数啊，然后来实现这种各种各样的转换变化啊，这个函数呢，我们可以把它作为image的这么一个程序函数啊，程序函数看一下。
首先啊，我们把这个函数先移出来，因为这个函数呢，它一般啊，不会被外界调用，所以说我们在这把这边啊，把它。
OK，然后在这边我们开始写这个函数啊more set叫image layout。
OK，那么只要是不是这个函数只要一调用啊，我们就希望它能够被转成我们需要的格式，对吧？
好，那么在这里面呢，我们看一下需要什么样的参数啊？
首先呢，要转换哪张图片，其实这个就肯定在这儿了，对吧？
就是转换这个类里面的这张图片嘛，然后呢？
我们需要啊，有它的一个原来的layout是什么，然后新的layout是什么，对吧？
那么这个问题怎么解决呢？
我们就把这个layout呀，就只想记录到这个layout里面得了，对吧？
啊，叫vk image layout哎，它当前这个图片属于什么样的layout当中啊？
我们都是知道的是吧？
OK，那么这样的话呢？
我们呃，就把它进行一个初始化一下啊，叫vk。
啊image layout undefined啊，变成这样的格式初始化OK，然后呢，在我们image生成的时候啊，我们为了这个严谨啊，也需要给它在这边儿先写上一个初始化。
阿迪vk MS。
layout undefined,OK?这样比较严谨啊。
那么，我们走到这里啊，我们就知道了，好，我的old layout，原来的layout就是这个，对吧？
我永远会记录在这张图片里面，所以说呢，我需要先传入一个image layout，这个layout是什么呀？
就是说呢，是我的啊，目标layout就是我的new layout。
好，那么接下来呢，就是我要变换的这个阶段，对吧？
这个依赖阶段什么意思呢？
就是说呃，我们上节课讲到这个barrier，这个barrier我们会在这个set image这个函数里面去做啊，在这里面去做，所以说呢，我们就需要被这个barrier也传入一些函数。
这个barrier重要的参数是什么来着？
是不是说啊？
这个barrier它上一个阶段是什么？
那么下一个阶段是什么？
上一个阶段的什么样的操作？
影响了下一个阶段的什么样的操作？
对吧？
所以说我们要有一个阶段啊，这个阶段什么呢？
就是vk fly。
stage,thanks.诶，这么个东西对吧？
叫source stage。
mask那么我们是不是还需要一个desk？
对不对？
就是依赖于source的这个stage啊，那么叫做desk stage mask？
OK，那么我们现在有了这两个问题，对吧？
那么接下来呢？
我们还需要一个什么呢？
就是sub resource range啊，这是一个必要的参数，我们把这个参数调整一下啊，涉及到locken的这个函数啊，它就会这样比较，怎么说呢比较？
啊长啊，这个参参数列表，所以说我们经常啊会做成这种格式啊，叫做vk image subr sub range。
诶sub resource resource range诶，这个东西啊，叫做saber resource呃，saber resource range。
okay，我们看一下这个saber有效数据是什么？
好，大家看一下，首先是aspect啊，这个就很像什么呀，大家发现了吧，很像什么呀，是不是很像vk image m对吧？
也就是说呀，我单纯的去转这张image，其实怎么着不太合适啊，因为这个image里面很多的啊，这个mip map。
啊，它还有可能是color类型的，也有可能是这个depth深度类型的啊，都有很多种可能性，所以说呢啊，我们就需要这样一个东西，类似于Vicky image view啊，这个框一下就是说你到底要转换这个图片的哪些方面这个意思？
好OK，那么基本上的话，这个数这些参数就差不多了啊，有我们再多退少补是吧？
现在我们去到这个实线里面，我们试一下啊。
拷过来戴上顶帽子。
好，那在这边的话呢，我们啊应该怎么办呢？
首先我们是不是应该申请一个呃memory这个image memory barrier对吧？
就可以image呃memory barrier。
搞一个barrier出来啊，这叫做immense memory barrier。
好，那么这个barrier我们给它置空啊，接下来呢，我们来填写这个barrier相关的信息啊，首先是它的s type。
等于vk structure type啊，image memory barrier啊是这样的barrier。
然后我们填写什么呢？
填写它的old layout。
就是它原来的那个格式，那么就等于我们的m layout就好了嘛。
然后它的new layout就等于我们传入的new layout。
好，那么接下来呢？
我们要填它的source啊，这个q family这个的话呢，就是由于啊，我们现在并不是去转换这张图片的啊，关于队列的所有权，所以呢，这个东西我们并不关心，对吧？
我们只是转换它的格式。
所以说v kq family啊，ignored就可以了，我不关心啊，那么接下来它的desk q family，我们是不是也是不关心啊？
对吧对？
哎，不关心就可以了，那么接下来。
看一下啊，它的image。
那么是不是就我们的le match？
那么，它的sub source range就等于我们提供的sub resource range，哎，等于这个。
好，然后这个sub resource range具体该怎么填呢？
这就是哎，这个我们在外界啊，在这个类外面该考虑的事情了OK，那么接下来呢，我们要考虑考虑就是说啊，为这个barrier我们看一看它还有什么参数啊，你看这个barrier里面啊，还有这个access flags是吧，还有一个source test ask和desk access mask。
就是说这个呢，什么操作完毕了，下一个阶段呢，什么操作才能够做啊，那么这个东西我们应该怎么去做呢？
你看啊，这个我们要自行判断一下啊，其实我们判断的依据是什么呢？
是依据于这个你呃，这个这个啊。
old layout和new layout的格式，我们是依据这个来判断的啊，为什么能够依据它判断呢？
我们看一下我们首先啊switch。
我们选项选什么呢？
我们的old old啊，都是ML的啊诶。
好，我们选一下我们的old layout，我们看一下，如果vk image呃layout undefined的话，那么你看啊？
诶诶，如果是这种格式，我们显示出这如果是无定义。
五，定义layout。
说明什么呢？
说明图片。
刚被创建且上方啊，或者刚被创建对那么上方一定没有任何操作。
所以啊，上方是一个虚拟的一类，对吧？
是这个意思诶，那么我就很清楚了，好那么这个barrier的。
source access mask就给为零啊，这个零就是我不关心你啊，我关心你对吧？
所以呢啊，上方无上方没有操作的话，所以啊，不关心上方的这上一个阶段的任何操作。
其实呢，就是什么呀，就是无依赖嘛，是无依赖对吧，那么同样我们在这儿再写个思维导图。
我们switch一下new layout这个东西啊诶。
new layout好看一下啊，我们的目标是什么？
我们的目标是把它转换成哪个东西呢？
是不是转换成一个transfer的desk对吧？
那如果它是一个vk image。
layout transfer desk optimal啊，好break up，我的目标是。
你看如果目标是将图转换成为一个啊，复制操作的目标图。
图片啊，或者说目标内存。
那么我们就想想了，那么我们做规定啊，什么样的操作在等待上面呢？
那么，被阻塞的操作？
一定是写入操作，没错吧？
大家想想被阻塞的操是写入操作，对吧？
那我们看啊，当前上方我不管用什么样的操作，你在对这张图片进行任何的操作啊，那么我中间插了个barrier哎，我下面就要使用这张图片了，那么我希望它成为一个被传输的目标点。
那么是不是说我接下来想要去向这张图片写入数据，我才会把它转换成为desk optimal对吧？
诶，那么我当然就要在写入数据的这个地方去等待它喽啊，所以说呢。
诶，它的再次ses master就一定是什么呢？
vk access。
这次方right beta 1定是这个啊，一定是这个OK，那么我们再想一想啊，接下来还有一种情况啊，假设我们现在的图片已经是这个形式了，对吧？
因为我们还有第二个转换需求嘛，就是将图片从这样一种格式转换成为什么呢？
转换成为啊。
这个格式image layout shade read only它要用于采样，比如说sheet read only啊break好。
那么我们看一下，如果说啊上方啊，原来的这个layout，它是一个desk optimal的话，那么我需要，那么我接下来要对它进行任何的操作的话，我需要等待上方啊，上一个stage的什么操作完成度才能对它进行内存操作呢？
你既然是个desk的话啊，既然是个desk的话，那么一定是会被写入的，对吧？
你既然是会被写入，我就要等你被写入的这个操作完成啊，所以说s就等于。
这个我等待你写入完成啊，大家思考一下啊啊，现在我所讲的这种，它都是说相互之间是互相独立的，要互相独立的，因为它现在的原始格式是dest，所以我判断说啊，这个dest 1定是一个被写入的目标。
那么我一定要等到它被写入之后，才会对它进行各种各样的操作啊，而不是说一个呃，这个因为我们刚才所提出的那个需求啊，什么先转入什么再转出啊，并不是这样的啊，这个相互独立的。
OK，那么接下来我们就看一下啊，如果我想把图片转换成一个什么呀shared readonly，大家注意啊shared readonly，我接下来我们判断一下需要进行什么操作，那是不是说这个白面完成之后，我接下来要读入这张图片进行采样啊？
所以说呢，我既然要转化成这样一个量，我一定是要对它进行读入的，所以我的desc ssess mask就一定是vk osess诶，叫什么呢诶？
vk vk osess。
啊shared read bit对吧？
我要读这张力的话，我一定要啊，这个是被阻塞的操作啊，是被阻塞操作，我们就写在这里啊，你看如果。
如果目标是将图片转换成为一个适合被作为啊纹理的，哎，这边我们适合被作为纹理的格式。
那么，被阻塞的操作一定是什么读取诶？
这个意思好，那么我们这两个就完成了啊，就完成了。
那么接下来。
啊，我们就要写一个操作指令了，对吧？
因为我们当前的这个转换啊，我们只是填写了一个barrier，我们接下来呢，把这个barrier什么送到队列里面去执行啊，送到什么队列呢？
是不是送到我们当前这个graphics q就可以了是吧？
因为它那个转换可以通过graphic graphics q来做啊。
我们现在去到卡玛泽八里面，我们要添加一个指令。
我们放在哪里呢？
就放在这儿啊，void叫做呃set image layout啊，这么一个操作呃，或者说叫transfer transfer image layout。
啊，转换好一个量，那么我们接下来要传入什么样的参数呢啊？
首先呢，我们肯定要传一个every了，make image啊，叫做buffer啊，不in memory啊，bar这样子。
image memory.area那么，接下来我们还需要传入什么东西呢？
是不是它的source stage mask和desk stage mask对吧？
叫vk pipeline。
呃，叫做stage flex。
source stage.然后呢？
可以可以pipeline。
呃，stage must呃，stage flex。
叫做desk stage。
mask OK，那么其实我们只需要尝这些参数就足够了啊，我们看一下其实非常简单啊，这是一条指令的问题啊。
去到这边看一下怎么填写啊？
把帽子拿过来。
好，那这边呢？
我们只要调用vk cm d pipeline barrier就可以了啊，这样的话，其实啊，它是向这个命令之中插入了一个image的barrier啊，插入一个barrier，这家伙呢，它可以插入各式各样的barrier啊，这样子。
好，那么我们怎么做呢？
首先是对于哪个命令啊？
还有command buffer啊。
其次，我们看一下数啊，就是source stage mask source stage mask，然后desk stage mask，这个依赖的stage，然后接下来是。
接下来参数是什么呢？
是啊dependency flex是不是啊？
嗯，那么我们先写个零，然后memory barrier count。
我们memory barrier count的话肯定是零嘛，对不对？
我们又不是memory barrier，我们是一个match barrier，然后呃，memory barriers这边是什么now btr这个参数诶，这参数我们做一下规整啊。
那这样来写它。
诶，这样来写啊，这边我们加个注释，这个注释这么写啊，这个是为了就是memory barrier。
啊，普通白酒。
然后呢，接下来我们看一下还有什么参数啊？
我们就写了这个为零，然后这个为零，这个为now接下来呢是buffer memory barry啊，另外一种barry对吧？
是另外一种barry，那么我们也是零和now对吧？
好，这两种variable还没有给大家介绍啊，所以大家不要慌啊，这边并不是老师跳过什么内容，而是说我们这节课要用的就是image的啊variable 0 now。
这边是阿尔法a。
barrier好，那我们再看一下。
呃，接下来呢，才是说我们到底有多少个image barrier要插入啊，然后说image barrier的这个data这块就简单喽，对吧？
我们插入的是一个image barrier啊。
然后呢？
是诶，应该是number barrier，但是这个地方呢？
是不是有问题了？
各位同学啊，这边是有问题，对不对？
你看我们传的是什么？
是一个临时的变量啊，是一个临时的变量，这样的话是不对的啊？
所以说我们应该是const，这个引用是吧？
h面料呢，在这边肯定出了作用域就死了啊，肯定不能这样做。
我们所以说改一下啊，这边的参数需要改成这样子诶。
没有拷贝过来。
好，okay。
检查一下啊，检查一下，应该没有问题啊，没有问题好，那么我们再回到我们的image里面啊，在这里是不是我首先要做一个command buffer才可以是吧，所以command buffer呢，就需要很多东西了啊，好，那么这个内容啊，接下来做command buffer的内容我们。
留到下节课来做。

