07-01.Vulkan-指令与多线程理论

各位同学大家好，我想讲一下指令缓冲。
那么，我们先看一下知识的总结啊，我们现在啊，所讲的部分其实是位于这个地方的啊，这个红框框起来这一部分啊，这一堆东西所执行的就是指令缓冲，所执行的东西。
比如说呢，把一堆啊小命令放到一个大命令里面，然后送入到渲染任务队列，随后渲染完毕，再把它送出来，对吧？
这个过程就是指令队列。
那么我们看一下啊，command buffer这个在w当中非常重要的概念。
指令在open当中呢，拥有恶劣的指令，比如说啊，它要绑定一个v bo啊，什么是v bo来的，学过ogl的同学都知道啊vo，它是指的在gpu当中开辟了一块显存。
然后呢，里面存放的是这样一个模型，它的顶点数据，那么我们在绘制的时候就要知道我要绘制的是哪个物体，那么我当然要绑定上这v bo，然后从这个缓存里面去读取数据，然后进行绘制。
那么，再比如说绑定uniform以及最终的一个重要命令啊，绘制命令还有呢？
我们还学过啊，之前讲过有一个叫barrier的东西。
那么berry呢，也是一个指令啊，它可以更改图片的格式图，图片的这个layout啊，比如从undefined更改成为color attachment optimal，那么这些都是通过command执行的。
所以我们的任务啊，就是要设置任务的队列，然后呢，要设置任务的八分啊，然后放入队列执行okay，那么这个就是指令。
那么，指令缓冲是干嘛的呢？
我们知道啊，从指令做，肯定是从CPU端进行制作，那么制作好的指令呢？
肯定是放在CPU端的缓呃，这个内存里面。
然后从CPU端发往gpu呃，那么它是一个非常耗时的行为，所以呢，我们不能弄一个指令就发一次，弄一个指令就发一次呃，这样的话太耗了。
所以我们需要把指令及其参数录制到一个command buffer当中，统一提交给CPU，然后一口气的执行啊，那么所谓的这个指令缓冲啊，就是command buffer，我们可以理解为在CPU端的内存当中的一块儿。
然后呢，把所有的乱七八糟的指令以及参数呢，把它放到里面啊，这么一个东西好。
下面我们来看一看录制这个词儿啊，刚才我们讲了是录制到一个打法当中是吧？
那么指令缓冲呢？
其实就是一个CPU的内存空间broken，将我们输的指令及其参数。
那么，做成机器可读的二进制数据啊，然后存放到这个内存空间，这个过程就是指定的录制啊，那么其实就是一个序列化的过程啊，序列化的过程OK，那么我们再看举个例子，比如这个指令vk啊command band pipeline。
那么，这个指令干了事呢？
我们看一看啊，那么第1 command buffer这个参数就是指向指令缓冲的句柄。
那么，第二个参数表示什么呢？
表示管线是用于graphics呃，就是用于绘制图像的，然后第三个参数就表示绑定的是哪一条管线的距离。
那么，这个指令调用之后呢？
就会产生这样的结果啊，后面两个参数就是这两个会被序列化为二进制的数据存放在谁啊？
这个command buffer里面当然由于掉了这个band pipeline，这个指令那么这个指令啊，它肯定也有一个字节序号对吧？
也会被录入到这个command。
八号里面如此类的指令呢，会有很多种，那么有这些指令一条一条的录入到这个卡巴巴号的过程啊，就是一个呃包块的过程。
那么我们看一下。
command buffer呢是可以分类的，首先primary command buffer主指令缓冲用于直接向gpu提交啊指令的缓冲，这么个东西，然后secondary command buffer叫二级指令缓冲它呀，可以将指令录制到这个缓冲当中。
然后呢，把这个缓冲的内容啊，把它输送到主指令缓冲当中进行执行。
它自己是没办法提交执行的，必须放到一个primary command的里面，那么我们看为什么要设计两个种类的指令缓冲呢？
那这个原因通常在程序的设计当中啊，每一个object。
我们都会为其分配一个二级指令缓冲，它是干嘛的呢？
它需要录制它自己的指令啊，就是属于这个object的指令，比如说啊，有object使用管线。
那么，不需要推送uniform，那有的就要推送uniform，有的呢，需要推constant，有的不需要推constant啊，等等吧，都不太一样，那么所以每一个呢，录制自己的指令，然后统一递给谁啊primary？
第二点，很重要的点是什么呀？
方便使用多线程确认啊，这个很重要，我们看一看啊。
这个多线程渲染啊，就是vulkan相对于OpenGL的一个极大的性能优势，那么怎么理解呢？
那么我们首先理解一下抓靠啊，那么什么是抓靠？
为何呢？
抓靠又很耗时间。
在传统OpenGL的渲染方式当中，它是保留着状态机的模型，并且这是个单线程啊，那么第二点我们看一看，将目前设置的OpenGL状态，比如vpo的绑定，纹理的绑定等做成指令。
送入gpu队列执行就是一个桌框，这个过程在CPU端执行跨，怎么理解什么叫目前设置的ongl状态呢？
我们知道ongl是状态机在里面的话，我们绑定一个vpo叫band指令。
啊，那么既要办打粉对吧？
绑定一个纹理，既要办texture，那么这些啊，它们并不是指令，它们只是设置了当前OpenGL状态机在哪里啊？
在CPU端啊，也就是说在我们的普通内存里面的一个状态。
啊，记录在这里面的，然后呢，我们发送一个gld raw array，或者是说gld raw index，那么它就会把这一堆的状态啊，编译成指令。
那么，编译成指令，这个过程其实和我们刚才啊调用各种balken的amount差不多，它弄成指令之后啊录入CPU gpu队列，但是。
如果有十物体需要绘制，那么我们就要做十万次的抓扣。
最可怕的是什么？
它线性执行的也就是说十万个物体的抓扣依次排队执行。
啊，那么在CPU端肯定就会消耗大量的时间是吧？
反正CPU会偶尔通知一下，那肯定就留着钱浪费了，对吧？
十万物体搁那排着你CPU稍微大了一点也不行，而且你CPU还空起来好几个核心。
对吧，那么就很浪费了，在vulkan里面怎么做的呢？
我们看一看，因为vulkan它拥有了二级指令化工，所以我们就可以把装靠的过程做成多线程的组装。
具体怎么做呢？
假设我们有三个object，三个物体，这三个物体啊，分别给它们分配一个二级指令缓冲。
然后每一个都跑成一个线程。
那这个线程干了些什么事情呢？
它呀，是将每一个指定缓冲啊，各自进行填充，各自的东西啊，这边填噢，这个一这边填噢，这个二这边填噢，这个三啊都填满之后呢，那么这三个线程就统一转起来，也就是说三个线程执行完毕啊，统一在这里消亡。
停止转完毕之后，那么接下来诶，需要把这些汇聚成数组提交给主指令缓冲。
而且我们发现，由于每一个都有自己的指令缓冲，是不是就可以做成线程无关，对不对？
它们彼此之间不用加速了啊，那么就可以充分的跑在多核处理器上。
那如果说你只有一个主旨令缓冲，你就算开好几条线程，那么这些线程呢，也都是向主旨令缓冲提交，唉，这边它就属于一个什么呀，属于一个中途的地带，那么这边肯定就要加锁了，那其实跟你单线程没有什么区别啊，性能还不如单线程。
OK，那么这个其实就是啊，多线程选择本质，它把这个桩号给平摊掉了OK，那么我们这节课就讲到这里。

