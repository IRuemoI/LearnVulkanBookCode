各位同学大家好，我们这节课呢，来讲解数组，那么首先我们看一看顶点数组解决了什么样的问题，我们目前的三角形的顶点信息是写死在 shader 当中的，就在我们的顶点着色器当中，如果我们想在 c 加当中将顶点传入管线，我们该怎么办呢？也就是说我读入一个模型，把这个模型数据送入管线的话，我该怎么办？那么在 Web 里面是用顶点数组的模块，那其实这个名字估计大家在 Opengl 的课程里面已经听过了，那它就是VAO，那么与 VAO 相对应的就是VVBO，是一块显存空间。

它里面存放着Vertex，也就是顶点的数据，那么为 AO 是一堆的，为 bo 所形成的一个顶点数组，它是一个逻辑的概念，那么对应到 Vulkan 里面，那么它就写得更加的详细了，它允许我们操控更多的东西，那么在 Vulkan 里面这个顶点数组它包括了一 GPU 显存空间。

第二个就是对这个东西的描述，那么我们看 GPU 是用来存储数据的，并且向 shader 提供数据，而描述是用来告诉 GPU 你这个存储空间当中，那么读取多少数据，怎么读取数据？每个数据含义是怎么样的？怎么去使用，所以说存储的空间以及描述符缺一不可。

那么我们看一看在 lock 里面是怎么去描述的，这个在这里会给大家逐步展现顶点数组的一系列的描述方法，那大家也要在这仔细的看，首先给到大家两块 GPU 的显存空间， GPU 0 号、 GPU 1 号，这是两块空间上面，这块空间里面存着的是紧密排列的顶点的位置信息，这都是顶点的位置。 XYZ 第二显存空间存储的是顶点的 UV 信息，这边UV，对吧？都是紧密的排列的，连续的这么一个数据信息。

那么接下来我们把这两块 GPU 的显存。他们在我们的 CPU 端肯定是要有 handle 的，对不对？我们都知道 Vulkan 是通过 handle 来对 GPU 端的内存进行操作，那么我们把它放到一个 handle array 里面，这是一个很简单的一个 Vector 数组，然后做成数组之后它会被放到 command buffer 里面去绑定，那么所以说我们有这样一个简单的步骤来理解一下，那么这是在干什么？这是在绘制的时候告诉 GPU 说我要用这两块显存空间所对应的顶点信息去绘制，对吧？这就是这两个 handle 所对应的空间，告诉通过 command buffer 形式告诉 GPU 了，那 GPU 它是不是收到之后它就说我知道了这一块，反正是一个内存，这是一个内存，我就从这两块就读数据，但是请告诉我，但是请告诉我这两块的空间的数据我怎么读呢。我读来干嘛呢？都表示什么含义他不知道。

所以说就需要接下来的描述，我们来描述一下他 vertexinputdescription 这样一个描述结构，那么第一个描述结构就是 0 号，他告诉 GPU 说 binding 等于 0 的位置的那块内存，什么叫 binding 等于 0 呢？其实就是这个数组里面的第 0 号位置，这个就叫 binding 等于0，也就是说这块内存，他说这块内存 stride 等于12，什么意思呢？就是说那个 12 除以 4 得3，为什么除以4？因为 float 类型的数据是 4 个byte，那么 12 BYTE 除以 4 得3，也就是每 3 个 float 类型的数据为一组代表一个顶点的某种属性。但是我现在还不知道他是什么属性，我只知道说每三个切一刀，每次切一刀这边反正就是一个顶点属性吧。然后他告诉就说 inputrate 等于 rate of text，这是什么意思呢？也就是说每一次 Vertex shader 的执行，那么它是按照逐顶点的方式的，也就是说每一个 Vertex shader 的执行都代表着一个顶点数据，一个顶点的所有数据的执行。

那么与此相对的是什么呢？是instance，所以这边大家还没有讲到 instance 啊。那么所以说先就这么理解就可以了，比如说逐顶点去通过我 time 直接 shader 处理，然后这边还有一个description，他说 binding 等于一的那个 GPU 数， GPU 显存，那就是这个 handle 所对应的这块，对吧？他说 stride 等于 88 除以 4 的2，对吧？也就说每两个 float 类型的数组为一个顶点数据。好，那么我们就知道了，第0个顶点的数据是用这三个数据加这两个数据拼起来所构成的，但是我并不知道这些数据还代表什么，对吧？我现在不知道。

然后我们把这两个描述信息也变成array，这边写错了，不应该 handle 叫，应该是 description array，是吧？大家先这么看，把这两个信息放到这个数组里面，给到谁给到的是pipeline。好，那么我们从中间切一刀，这边就是真实的数据信息，对吧？这个是真正的模型数据，然后是通过 command buffer 送进管线的。送进哪条管线呢？送进这条管线进行处理。那这条管线拿到的是什么呀？他在 command buffer 执行之前，也就说创建这个管线时候就已经把这两个描述信息变成数组给到他了。

所以说 pipeline 本身它是一个什么来的？是不是它是一个模板，对吧？它是一种渲染方法的模板，那么它这两块信息就描述了，告诉这个 pipeline 说我这个 pipeline 它要输入的就是这一种类型的数据。什么类型的数据？就是这种，就是两块显存，反正第一块它是 12 INT rate 等于这个，第二块 strate8INT rate 等于这个，所以说一刀切右边的这一堆东西是描述了一种模板，而左边的是真实的，OK，那么我们接下来看我们该应用这些数据的时候到了，说这些数据到底表示什么含义啊？好，我们清一下屏，是吧？看一看，我们还是两个数组，那么各自有各自的描述信息了。

好，那么现在呢？我们给到一个 what text shader，这个 what text shader 大家都知道这边就是 input 的录入数据，它说 location 等于 0 的地方会输入一个 Vector 3 的类型的 position 的信息，我们知道了这个是position，那么 low location 等于一的地方会输入UV，诶，大家看这个 location 等于 0 和一，是不是这两个？并不是的，所以说我们要加一个描述信息，就是对于 attribute 就是它的属性的描述， attribute 的描述，这两个东西就叫顶点的attribute，顶点的属性，你看位置是不是属性又是属性，对吧？那么我们看一看 attribute 到底描述了什么啊？先拿这一块看一看， binding 等于0。

哦，我知道了，说反正这个 attribute 它指的是 binding 等于 0 这个 GPU 数组或者 GPU 显存的地方，它指向这说 location 等于 0 哦。我们知道了这有个location，它俩是不是可以连起来，对吧？你看这个 location 是从这个 attribute 里面去依靠它来找信息、找数据，怎么找呢？ binding 等于0。

好，那我就去 binding 为 0 的这个数组里面去找，哎，就能找到，是不是？然后他说 float 等于 RGB 32，什么意思呢？就说你也不要去理解这是什么颜不颜色的，只是一种说法，一种格式信息其实最主要的想表达就是说这个地方一口气从安定等于 0 的给我取出这个 3 个 32 位的数据。

什么是 3 个 32 位啊？不就是说 3 个 4 BYTE，三个float，是吧？一个 float 就是取出 3 个 float 数据来，于是这三个数据就被取出来，哎，丢给这个 position 了，并且 offset 为0，也就是说不需要进行这个偏移操作。

那么我们再看看这个UV，我要取 UV 等于一的这个数据怎么取呢？从这找一找，说 location 等于一在这，那么它是从 bind 这边应该是写错了。我们把这稍微一下， binding 为一，好说这个一从 binding 为一的这个显存里面去读，找到它这是显存在这，然后读 32G 32，就是读两个 float 出来，一二读出来，这两个读出来之后 AOV 并且 offset 为0，好，就是这样一套含义。

所以说我们可以稍微做个小总结， input description 它是描述了一个Vertex，那比如说它是用来干嘛的呢？我们再仔细想想，我们现在有两个 GPU 的显存。那么这个信息就是用来切割这个显存空间的，用来表示说一个顶点切一刀，他在描述这种切割信息的attribute，它是来描述什么呢？与 shader 所对应的每一个顶点的这样一个属性去哪里找？那么我们就会提出一个问题，我们仔细看一下，如果单纯的使用这种 attribute description，是不是就可以知道从哪个 buffer 读取数据了？因为 bind 等于0，是不是直接到 0 号那个 buffer 去读就好了？读取多少个就通过FMT，多少个 float 是不是就通过 FMT 来决定？然后给到哪个 shader 的变量就通过 location 来决定。

我们就发现是不是这个 attribute description 自己就能搞定这件事情了？那么vertexinputdescription。就那个切割用那个会不会多余了？难道它只能发挥控制输入的 rate 的功能吗？你看切割我们都免了，是不是？如果对于 position 来讲，是不是 RGB 每个 RGB 读一个，那就是每三个 float 为一组往这去读，哎，是不足够了。其实并不是的，并不是，我们看一看这样的情况啊。

对于 intlived 类型的顶点数据，那就不简单了， vertexinputdescription 负责告诉 GPU 说读取下一个顶点需要跨过 5 乘以 sizeoffloat 这么多的stride，也就是说你看这是 intlive 的类型。

我之前给大家讲过，把顶点的 position 数据与 UV 数据放到了一起，在一个球里面，在一个 GPU 的 buffer 里面，那么我们读取下一个顶点，至少要跨过，是不是 5 个float，对吧？所以说 stride 为5。那么所以它是描述顶点信息的，你单纯的用这个是不够的，你看单纯的用这种 attribute description 来讲它就做不到了。

那么好，我们再看看这个，给大家出个题目，如果是这种情况的话，那么刚才的那个 shader 就是 location 为0，是position， location 为一是UV，那应该怎么去做？是不是 binding 等于0， location 等于0，读这个 offset 这个没有问题，对吧？第一个顶点我们跑到这个地方来读， binding 为0，那么就这个数就是这个 buffer 了。

location 为0，那么就是position，那么读取 3 个 float 123，那么上面这 3 个白的就被读走了，OK，那么对于第二个描述来讲， binding 仍然为0，对吧？因为我们只有这一个buffer，那么 location 为一代表着UV。

float 为什么呢？ R3232G 32 读取两个 float offset 应该等于什么了呢？是不是 offset 应该等于偏移 3 个 float 从这开始读，对吧？读UV，所以说应该从这开始读两个来给到UV，给到 location 为一的位置的那个变量，那UV，所以说其实 attribute description 是描述了在一个 Vertex data 里面一个顶点数据里面怎么去再细粒度的切割，并且给到 shader 的这么功能就是它，而如何在这个 GPU 缓存里面去切割大整块的数据，是 Vertex input description 来决定的。好，希望大家把这节课也能够听明白。

