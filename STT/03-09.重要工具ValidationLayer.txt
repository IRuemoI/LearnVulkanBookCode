03-09.Vulkan-重要工具ValidationLayer

我们都知道awoke呢，它是一个什么呀？
它是一个最小驱动上层的API，所以像debug的信息输出以及调用的校验就变成了一个layer层。
啊，那我们首先解释一下啊，说为什么会把这个debug以及信息的输出调用的校验这些东西给独立开呢？
呃，那是因为啊呃OK in它追求的是性能啊，一定要快速的运转，那么你想如果我调了一个API，他检查了我的参数，然后他又检查了我的各种行为，他又做了if else。
还做了打印，那么这件事是不是非常的消耗性能啊？
还做了IO对吧？
那么我只有把这些东西啊，全部都关掉，那才能形成一个最快速的运转。
那么但是我在开发期间呢，就还得把这些东西打开啊，因为我可能会犯错，对吧，所以说呢，像violation layer这个东西啊，就可以打开或者是关闭我们在研发期间打开它，然后来输出debug信息，看到底出了什么错，看到底进行了什么工作啊，然后呢，我们在release的时候。
就把它关掉，然后发布出去。
OK，但是呢，有个问题啊，很多同学一开始接触它的时候都觉得为啥这样呢？
一层这怎么会叫层呢？
这就很有意思对吧？
我们看一下啊，它是一个这样的。
函数调用，你看我们在这个地方啊，进入一个函数调用，现在做了很多工作啊，做做做工作，然后呢，如果没有这个红色的话，它就会继续掉这个函数的东西啊，继续往下走，但是如果我们开启了这个validation layer的话呢，它会在调用的中间啊，插很多这种的层啊，一层一层的插进来。
这层要干嘛呢？
校验上面的结果对吧？
可能这还要插一层啊，再校验上面的结果，可能如果上面出错的话啊，它就会比如说我们呃，这个内存是空的，它就会打印啊，说这个内存不打，我们调用个null的对象，这样是不对的啊，所以说呢，就是在函数当中啊，插了一层又一层这种。
这种校验层啊，其实它可能是一个if else啊，也可能是个什么东西混合校验对吧？
OK，那么我们再看一下啊，关于validation layer的启用啊，首先呢，在instance当中啊，有专门启用validation layer的功能啊，它需要知道你启用哪些validation layer启用了多少个validation layer？
然后呢，还要在instant当中啊，增加对validation layer的扩展，开启啊，扩展我们都熟了是吧？
那增加它的扩展就好了，然后呢，我们创建一个回调函数，因为在validation layer开启之后呢，我们每次调用API的时候啊，那里面校验出了结果，总要需要给到我们这个客户端吧，对吧？
总要给到我们的主程序吧。
那么，我们主程序传入一个回调，它就会调用我们这个回调函数，把相关的信息给到我们，如何去打印，如何去输出或者是如何去做紧急的处理，都是我们自己来说的。
然后是管理一个句柄啊，都叫debug messenger这样一个句柄，那么这个句柄是干嘛用的呢？
它其实是呃，设置了很多信息，我们所有关于validation layer的设置啊，都会要知道一个infer里面，然后用这个infer去创建句柄。
而且这个句柄呢，在它创始后啊，还需要跟instance连在一起啊，所以说这个句柄呢，就是一个全局的状态符啊，也是一个全局的状态符OK，那么我们再看一看信息的级别在我们啊呃，设置这个validation layer的时候，我们要告诉系统说我想知道哪些信息，而我。
不想知道哪些信息啊，所以说呢，这个y对它进行了一些分类，或者是说分级。
那我们先看一看这个表示for，就是说呢，它是一个详细的信息，让你细细的给我打印出来，你不管它是错误也好，正常的行为也好，或者你只要干了一件什么事，你都给我打印出来。
然后呢？
是infer啊，比如说资源的创建，我创建了一个offer啊，我创建了一个device等等啊，它都会在infer里面打印出来，然后是morning你这个行为，它有可能会造成bug啊，它就会打印morning。
最后呢，就是error啊，你不合法，它可能造成崩溃的操作信息，对吧？
你就直接说错了，所以error诶，然后呢，它们的级别啊，是从这个往下啊，从上往下是逐次增高的，所以说呢，我可以这么看呀，如果啊，我当前的c我拿到这么一个级别啊，如果这个级别它是小于了warning这个级别。
比如说这两个我可以不打印，大于等于了网瘾啊，那么警告和错误信息，我可以打印过来啊，它这么一个功能，然后呢，在这些级别之下啊，又做了分类，比如说。
这个general general是发生了一些与规范和性能无关的事件啊，这是一些事件，然后呢，这边叫啊出现了违反规范的或者发生了一些可能的错误。
最后一个performance可能影响了w的性能啊，那么这一些信息的分类呢？
那么就是在上面的这个级别呃，下面啊，就比如说呃，我们可能得到了一个这个error，那这个error是哪一种error呢？
它可能是这样一个规范性error啊，可能是呃，可能是这样一个违反规范error。
也可能是一个影响它性能的啊，这么个意思。
OK，那么我们看完这些东西之后呢？
我们回到我们的程序里面啊，看一下我们怎么去开启一下这个validation layer啊，开启validation layer好，我们再回到instance点cdp里面啊，我们来从这里声明一个东西叫做const。
s CD啊vector叫做count查询啊，这个就是我们要启用的什么validation layers啊这个名字。
那么，这个VS等于什么呢？
等于。
我们这边直接用啊，直接用crowds给我们提供的就好了啊，叫做。
aav k.layer.kh ro nos chronos validation啊，这个就我们要启动的那个layer OK？
然后呢，接下来我们要去到instance里面啊，然后呢，去到instance里面，我们是想去设进去，对吧？
就是我想启用这样的层，但是在启用这样的层之前呢，我要做一个很重要的事情是什么呢？
我要是不是要看一看这一个validation列的？
这样一个种类啊，就是这么个玩意，对吧？
它是否是被我们的w系统所支持的啊？
所以在这里呢，我们加一个函数。
这边layers。
布尔叫track validation layer support。
我们看一下我们这个instance啊，是否是支持了我们的这个呃，这个validation layer的功能，这个validation layer的功能呢？
就是bronze包装出来应该是非常好用的，里面有很多的这样一个级别啊，包括说信息的这样一个细节啊，都是非常好用的，那在这里来讲的话，我们就先check一下啊。
好布尔叫做instance呃check。
OK呃，check的话怎么check呢啊？
这也非常简单，这个套路啊，相信大家慢慢就熟了啊，首先是layer count是吧，它总共支持多少种layer，那么用vk enumerate呃in instance呃enumerate instance layer problems。
这个这个很像哪个呀？
大家看一下啊，是不是很像这个enumerate institution这个啊？
也是这么获取的，那那么我们的这个layer也是这么获取的啊，首先有layer的什么layer的数量是吧？
看一下它调用哪些参数？
它的参数是啊，一个是数字是吧，一个是需要一个内存空间，我们现在还是不知道它有多少个啊，还是不知道它有多少个，所以在这边呢，我们先把数字传进去啊，就这个layer count。
然后空间我们还没往那掉，拿到layer count之后呢，我们就同样的套路vector vk layer properties哎layer。
vk layer properties对，然后呢，available layers。
然后我们要给它分配多少个空间呢？
是layer count。
OK，拿到之后呢，我们就开始啊，为这个layer verbal layers填充啊，把所有的我们支持的每一个layer的信息都填进去zk enumerate啊，直接call过来啊。
然后啊，用它的data OK啊，这样我们就成功的把这个我们支持的列尔斯拿到了啊，那么我们要检查一下啊，这个列尔斯里面有没有或者说我们这里面所有的这个需要的，他这里面都支不支持是吧？
就做一次便秘。
for cons auto.叫做linear name。
在我们的validation layers里面查一查呃，我们搜一个布尔layer found。
那么等于force。
在这边呢for const我们再遍历所有的这个啊，再遍历一下所有的这个。
also，layer properties啊，layer prop，然后在available layers里面OK，一个是我们要的layer，一个是available layers啊，我看一下他们有没有如果哎，在这里的话，我们要做一些名字上的对比对吧？
名字上的对比的话呢，我们还是要在base里面把那个字符串加上那个look。
诶诶，回到这里，如果啊st d string compare。
去对比谁呢？
对比layer name与。
layer property的layer name啊，对比这两个，如果它们对比等于了零，说明什么呢？
是不是我们就？
没有问题了，就没有问题了，所以说layer found啊，那两者两个字符串相等嘛，说明什么？
说明我们刚才要的这一个呃，跟这一个layer是吧？
这一个layer在我们支持的这个available layers里面是有的，有的话呢，它就是等于了数。
然后break掉啊，说明这家伙被找到了啊，这这一个被找到了，那这个被找到之后，我们就不需要继续查找是吧，就break掉啊，那么再出来出来之后呢，它要再继续找。
啊，它再去找下一个，下一个有没有呢啊？
下一个name再去找一遍哎，有了有了之后就break是吧？
再找下一个name是吧？
这个意思，那如果说啊，只要有其中有一个name没找到，所以我们上面就有一个啊，对吧？
虽然说我们上面只有一个，但是呢，我们也要考虑一下，如果但凡有一个没找到假设有多的话，一个没找到就得干嘛，是不是就得呃返回错误对吧，因为我们需要的，它不支持，你看其中有不支持的东西，所以如果。
layer found 1旦没找到诶，那我们就得干嘛return for真的没找到啊？
如果这一堆都找完了啊return to。
OK，ctrl好，那么这个函数呢？
就是用来进行一次查找啊，就到底我们啊这里边有没有问题？
那么我们再考虑一点啊，就这个violation layer，它是有开启和关闭这一说的对不对？
所以说呢，在我们的in sense里面啊，在创建的之初啊，就要告诉他说我们加一个布尔量，布尔amenable。
elevation layer啊，我们可以加一个这样一个量，然后FALSE，然后呢，我们用这个变量来控制是否开启我们的elevation layer啊，那么这个东西在哪儿生成呢啊？
咱们在这儿。
instance里面，我们加一个参数，同时我们加一个参数，enable validation layer。
然后呢，同样这个参数我们是要啊，也是要在create函数里面加上的啊，然后把这个传进去，在在它啊创建这个智能指针的时候就把这条传进去了啊，传进去之后呢，那么在instance。
看一下那因此它的构造函数这边啊，我们也要给它。
那么，在一开始的时候呢，只要给它进行赋值啊，amenable velocity=enable velocity。
OK，那么接下来呢，我们就可以进行判断了，对不对啊？
我们已经知道了是否要启用校验层，是否要启用校验层？
OK，那我们看一下。
呃，在。
我们的这里。
如果啊，我是启用了校验层，我就在这查看一下我所需要的这个validation layers啊，那么你到底是否支持对吧？
所以说呢，我们在这可以这样写，如果enable validation layers啊，那么并且啊。
check validation layer support是失败的啊，这个是一个呃非嘛，对吧？
如果不成功的话，那么我们就得告诉他啊，你这个layer使用失败了throw。
s td run time l.叫做validation layer is not supported OK，not supported，那如果说这边我们检查通过的情况下啊，是不是下面就好办了啊，下面就好办了？
那么我们下面就这样写在这边啊，我们这边呢是加了扩展对吧？
所以说我们在这边要告诉他啊，这边是扩。
扩展相关，那我们这边是什么呢？
这边就是。
叫做呃layer相关。
那么，在这边的话呢，我们就直接给它，如果men able。
如果开启的话啊，那么inst create infer里面有一个enable诶。
有一个enable layer count啊，就是我要开启多少个layer？
是开启哪些layer呢？
是不是开启这个家伙对吧？
validation layers啊，等于validation layers的哎呦。
validation near ST.CON access.那么这个数据啊，它是不是一个size系类型对吧？
看一下啊，这家伙的返回的是一个size type啊，那么我们要给它做一次静态转换static cast。
嗯I int 32杠七。
OK，然后呢？
我们给它数量也要告诉它，说我们开启哪些validation layers，对吧？
把内容给到它inst infer点p呃，叫做enable layer names。
等于valid s的data。
好那么for else，否则。
那么直接把它count给零就好了啊，等于零好，那么这样的话，这个validation layers啊，就在这边被启用了啊，就被启用了，而现在还没有任何的行为，因为它没有回调，等等啊。
OK，我们运行一下。
有错误，我们看一下。
嗯，无法解析外部符号谁啊？
啊instance OK，这边我们还是要啊，这边刚新加了次数对吧？
然后呢？
在这边我们还没有改啊，在APP application里面没有改这个地方，我们做create这边呢，我希望启用吧啊，启用一下。
诶，在这个地方in MIT work里面，我们创造这个in sense的时候啊，没有加这个参数，因为这个create里面还是要有一个enable啊。
好，目前没有问题，但是你也看不到什么啊，应该meditation layers的回调啊，等等还没有生成OK，那么这节课先到这里。

