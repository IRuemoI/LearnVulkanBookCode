12-01.Vulkan-摄像机类介绍

OK，各位同学大家好，我们先给大家介绍一下camera就是摄像机的一个写法，那么呃，这个工程啊，是我们之前在教授OpenGL的时候给大家做的一个样例工程。
大家可以先看一下效果。
效果就是通过鼠标啊，你可以控制这个camera，它的上下左右的观看啊，然后呢，通过ws d你可以进行移动，在世界里面进行漫游OK？
那么废话不多说，我们看一下开幕栏的写法，他用到的理论知识就是咱们在第一章所讲过的这样一个view matrix的推导方法。
首先这里面有一个position就是位置。
然后是棒子，就是它这个看向的方向，然后就是up up的话呢，就是我们身体呀，它在大方向上大方向上来说啊，你的这个棒部是哪里？
就是指天空的方向，也许我低头，也许我抬头，但是天空的方向永远是y轴对吧，零一零。
然后是speed移动的速度，随后是p视角，所谓p视角什么意思呢？
通俗理解就是你平视前方的时候p视角为零，然后你仰头的时候呢p视角就会正角就会增大，你低头的时候p视角就会减小啊，它就会变成负值。
所以说p视角其实是你以你平视前方为零点，然后上下动头抬头或者低头的时候，这样产生的一个角度，然后是要要的话呢，就是说你当前与x轴正方向的一个夹角。
那么如果说呢，这个角度啊，给大家画一下。
这个是z轴，这个是x轴，这个是y轴，那么如果说你现在我们因为平视前方的话，是看向负z方向，对吧？
所以说呢，其实如果说啊，什么叫要角呢？
假设我如果看向这个方向的话，那么这个产生的角度就是要角。
啊yaw那么这个角度的话呢，它就变成了负值，为什么呢？
因为它只有冲方向才会是要的诶，一个正方向，一个正值啊，那么这个要的到这。
就是90度，那如果说你初始的时候是看向负z方向呢？
右角就是负90度OK，就这么简单。
好，那是要sensitive，什么意思呢？
sensitive就是我们如果要用来模拟啊，用来模拟我们镜头转换角度的话，与像素的一个对应关系，比如说我在一个屏幕上，我的鼠标从这个点横着滑动，到了这个点。
那么，请问就相当于说，在虚拟世界这样一个左右转头的效果，对吧？
我的头是转向右边的，那么我转了一个阿尔法角度，那么我转的这个阿尔法角度呢？
它就等于我的德尔塔x。
这段就是德尔塔x，就是我屏幕上所滑动的距离，乘以一个sensitive啊，这样做只是说对于这样一个角度的模拟而已啊，这是一个模拟，因为如果说你严格来算，这个到底在里面转了多少角度，如何去对应屏幕的话呢？
就很麻烦了，这样就很简单。
啊，包括你上下也是啊，上下是德尔塔y，那么我运动的这个塞塔角呢？
那么就等于德尔塔y×1个sensitive啊，这么个意思，所以说这个sensitive就是敏感度啊。
好，那么接下来这个是用来记录我们当前啊，就是上一次屏幕啊，上一次你的鼠标在幕上的一个位置啊xy嘛？
随后的话就是是否是第一次木五啊，这是一个状态，判断量那么接下来呢，就是一个video matrix，这个是我们最终算出来的那个呃，这个视图矩阵这个的话呢，就是我们最终要算出来的投影矩阵，所以说VP矩阵就可以在这里呃算出来了。
OK，我们看一下初始化camera，初始化的时候呢？
position我们给它设在了一个呃，这样一个一的位置啊，这应该是一个什么位置啊？
看一下啊，是一一一的位置啊，这也没啥问题OK，然后front看向上一个也是看向一一的位置啊，都给它置一了。
然后这个up呢，也是一一啊，都无所谓了speed零点零一，然后呢，它p是角是零，就是目视前方右角是负90度。
负90度就是看向这里，对吧？
那么你抬起来的时候，这个角就是你的p视角，对吧啊？
这个就是p视角了，就是你抬头的角度OK？
那么一开始p是为零，就是往前，然后呢？
要角为负90度，那么就是诶，这样向4d方向转90度，对吧？
负90度。
46是零点一，然后呢？
把这个关于鼠标位置的记录清0 first move呢？
肯定等于true了，对吧？
因为你还没有动过，一定是first move，然后呢v matrix的值啊为一个。
大家觉得接下来呢，我们看一下有个look at函数，这个是作为初始化来用的啊，这个look at函数呢，其实是调用了在m里面的look at，它会为你生成一个啊，计算一个视图矩阵出来view matrix。
你只需要传入当前的位置，然后呢？
你当前位置加上你的方向，这一步什么意思呢？
呃，这一步呢？
其实应该叫做你们看一下啊，这个叫做。
center啊center，什么意思呢？
在grm来grm里面来说哈，它这个第二个参数啊，就是你看向的那个点，那么你看向哪个点呢？
就是从我们再到这来看一下啊。
你这是它的，我们先用二倍坐标吧xz是吧？
那么你是看向这个方向来射，那么你呢？
所谓的front是从零点出去看的，但是因为你现在做了平移，对吧？
你到这儿来了，你的camera。
那么你肯定不能再看向这个点了是吧？
你不能看向这个点了，平移的话呢，你就应该看向这个点了，那么这个点是哪里呢？
就是你所在的位置，这个向量加上你的front向量诶front向量。
那么，开箱的这个点就是啊，就是这个点okay。
所以说就是这个道理，然后是你的up向量啊，这个没啥问题，这个的话呢，就是look at所做到的啊，应该是这边啊look at所所做到的，然后它的本你是可以进行初始化的。
front呢，也可以进行初始化up值，也可以进行初始化，所以用这个初始化没毛病，我们再看一下其他接口。
呃，先不看这个update，我们往下看啊呃get v matrix没啥问题，就是返回下v matrix get project matrix就是返回我们的投影矩阵啊，也没啥问题。
再次b的我们的移动速度move，这个move的话怎么做的呢？
它传进来的是一个camera move的这样一个一个啊，就是一个枚举，这个枚举啊，在这里啊，在我们这个类上边。
有由前后左右啊，前后左右这么一种，这种移动方式啊，那么如果是左边要move left，那么怎么办呢啊？
我看一看，那么我们的position就需要减去这么一串儿东西。
这么一串东西，里面的话呢，我们看看都是什么东西啊？
加cross front和up诶，我们看一下啊，它cross的front和front和up什么意思啊？
OK，我们新建一个。
xyz那么你现在假设啊，你看一下方向是这里吧，随便拉一下啊，看一下这这是你的front OK，它是说cross了front和。
up那么front up，代表什么呢？
我的up在这啊，在这对吧？
那么对于我个人来说，假设啊，就是我在原点上，假设我在原点上，那么它俩相cross from the cross up，我们可以得到一个这样的向量，对吧？
呃，大概是在这样的位置上，这样的位置上诶，那么这个向量呢？
与front垂直，且与我们的up向量垂直啊up OK，那么垂直于它俩所形成的平面，那么其实我得到了什么呀？
是不是得到了我的右边这个向量？
是不是得到我的右边啊？
那因为呢，我是move left，所以说呢，我就需要加个负号了啊，这边加了一个负号，然后呢，这边我把它normalize，也就是说我这个这个方向向量被变成了长度为一，它的lens为一，对不对？
唯一之后呢，这样我就得到了一个纯粹的方向，向量乘以4b的，然后被它减去我，那么我就是向左边移动了。
啊，就这么个道理。
同样，右边一动就加上了嘛啊，然后前方移动就是乘以from的向量就可以了，这个就代表前方减去就是向后移动，这个很简单啊。
OK，那么接下来我们看一下比较关键的pitch啊pitch是在干什么呢？
呃，首先我拿到了一个德尔塔y是吧？
这个是我相邻两帧之间鼠标在y方向上的一个德尔塔值差距，用新的位置的y减去旧的位置的y啊，在屏幕的这样一个坐标上。
然后p值就加上y乘以个sensitive啊，如果说我的鼠标是向下走新的位置呢，会比老的位置呀要小，那么一减的话，减出来的就是负值，那p值就会变，加上一个负值，那如果说我是鼠标往上的话p值加上呢，就是一个正值。
这个道理好，然后呢p是如果大于等于89度的话呢，那么让它停在89度，因为我们的脑袋呀，不可能说抬着抬着就翻过去了，对吧？
所以说呃，就这样子，那我也不可能低头低着低着，就一个前滚翻就翻过去了啊，所以说。
就是说如果是小于等于89度，89度，那么也要保持在89度。
OK，我拿到了当前最新的p值角之后怎么办呢？
我就要开始计算最新的方向向量了，我们看一看最新的方向向量怎么计算啊？
好对心的方向，向向是呢。
xyz.这个是当前的方向啊，那么当前的p直角的话呢，是这样子诶，我们画一条直线在这边啊，这个直线呢是在x黑轴所构成的平面上的一条直线。
画一条垂线下来，这个就是p视角对吧？
所以说当前我看向的方向就是这啊front。
那么，这个front呢？
它的y值是什么呀？
是不是这个p是l因为我的front是单位的向量，所以说它的y值应该是什么呀？
s in p值啊s in p值对吧？
所以说from they=s in p值l把它转化成弧度。
啊，那么关于xy怎么算呢？
我们看一下啊，那就需要用这条边来进行计算了诶，然后它呢是做个垂线垂直于x。
再做一条垂线，垂直于z好，我现在要算x是不是这条垂线啊？
对吧？
这条垂线是x。
那么，要角是什么呢？
这个是要角对吧？
这个是要角诶，在这那么x1定是用这条边的长度啊，乘以个。
cosine的要值对吧？
所以说我们知道这条边的长度是什么呢？
它就一定是一，因为这个是单位向量是吧？
一乘以个cosine的p就得到了这条边的长度。
再乘以一个呃cosine的腰，我们就得到了x对吧？
这两个cosine乘起来没有问题，那么关于z的话呢？
就是这一条边那么这条边的话应该是什么呢？
这条边的话，应该是用诶，这一条边的长度乘以个s in要是吧，所以只需要把这个s in要给它换成这样就可以了，所以说我们最新的房子上用完了，然后呢，把它normalize一下，做一下归一化啊，保持它的。
长度一所以呢，我们去调update啊，这边的话呢，重新设置一下glm的look at从这个位置啊，那么看向这个方向。
那么看向哪个点，对吧？
这个位置加这个点啊，这个位置加这个方向就是我们看向的那个点，然后是up啊，没毛病好，接下来我们看一下右往右转头德尔塔x进来了，乘以s我得到了当前最新的要值是吧？
就就可以了。
同样的计算，跟上面没有区别啊，没有区别要的话呢，你就不用去限制它的角度了，因为你的左右转头是随便转的啊，双的算出来update一下啊，做一下glm look at有没有问题？
好，那么接下来啊，关于移动，关于旋转，我们都做完了，我们看一看这个关于投影矩阵的设置，它需要传入几个参数，第一是你的angle就是个视张角，什么是视张角呢？
在一个视锥体范围之内，这是你的近平面，这是你的远平面，对吧？
你眼睛张开的这个角度就是你的视张角，大家想想你眯上眼睛看这个世界和你睁大眼睛看这个世界，感觉是完全不一样的，对吧？
那么就是这个angle，然后ritual ritual是说你的投影平面的一个昂高比啊，就好像是在这个地方啊perspective。
哎，这是你的宽度，比上你的高度什么的，宽度比上什么的高度呢啊，是当前这个镜行面啊，也就是说呢，其实就是我们当前这个桌面的大小，这个window窗口啊。
我们所设置的这个绘制桌面的大小啊，它的宽度，比如说800×600啊。
那么就用这个800除以这个600啊，就能得到这个瑞九。
然后是近平面和远平面啊，近平面的话呢，就是它距离我摄像机的距离啊，这一块就是近平面，远平面呢，就是远景台面距离我这个摄像机的距离，只有在这个视锥体范围之内的物体才有可能被显示出来啊，这就是啊，投影矩阵。
那么，我们现在投影矩阵也可以设置了啊，那么最终呢？
这几个函数就都完事了啊，我们调的时候啊，只需要这么来做就可以了啊，我们先生成一个camera。
看一下开关在哪里啊？
okay，这边我们一进来，这个命函数啊，这是之前写的代码啊，我们不是这节课的代码，但是可以看一看。
它呢，先把它做一下look at那初始化的位置，是一个z轴正方向三三个单位看一下z轴方向啊，看一下这个zz轴的负一。
然后呢，它的脑袋上方是零零零，随后它的speed我再set一下，然后呢，我就可以去set它了。
啊，我就可以塞它的perspective张角45度一个长高比变远程变啊就可以了，随后的话呢，根据鼠标的一系列操作，我们来进行改变OK好。
好，那么这节课给大家讲到这里，主要给大家讲的是camera这个类的各种接口，怎么去用它代表什么含义啊？
那么呃，在下节课呢，我们就开始把它加入到我们welcome的代码当中。

