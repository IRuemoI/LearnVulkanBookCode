各位同学大家好，我们这节课第一件事是整理一下代码，第二件事我们要做一下 swap chain 交换链的重建工作，我们先看一看，在这里面有一些东西我们需要做一次二次封装，比如说在这边我们有一个 init Vulkan 里面，这边我们做了一堆的这个关于命令的创建，我们也把它封装起来做一个函数 void create command buffers，那么我们去到这边把它写在下面这边，然后我们把上面的代码给移下来。

上面的这一堆，这个 command buffer 这边resize，然后到这边来，好，这一堆拿下来。OK，那么第二步的话我们还需要把这一堆给稍微封起来一下，成为一个独立的功能单元，就是关于 Semaphore 还有 fences 的一个创建，我们也把它独立起来。 auto create SYNC objects，好，这边 create SYNC objects，好，我们把上面的东西拿下来。

OK，然后接下来我们要看一看这个创建交换链的时候到底是怎么来决定尺寸的？我们来复习一下，这边我们有一个 choose incident，然后这边有一个 get frame buffer size，对吧？这边然后我们原来是将这个这边再给大家看一下，这边出来了，这个原来是什么呀？原来我们有一个长和宽，长和高两个量，一个窗口，然后这两个窗口的量是怎么设置的呢？是一开始我们通过创建 window 的时候设置进去的，现在只不过从里面拿出来，然后我们但是创建完交换链之后。

它的长和宽可能会发生变化，因为我们下面有一系列的对于长宽的调整，这边，对吧？所以说我们也得注意调整这方面的问题，去掉 application 这边，把这个东西，我们把它去掉，作为我们的内部变量，作为 application 的成员变量，把它放到这边，我们单独立出来。

int width 800， int height 600。

好，然后我们看一看哪些函数需要调整进入到window，那么这边 m 宽度。 m 高，OK，然后在这个位置我们创建完交换链之后，交换链会决定这个当前它这个整个画布 surface 的大小，对吧？我们在这边也做一下更新。 w 等于 swapchain get accident 宽度， h 等于 swapchain get accident 高度。好，我们运行一下，看有没有这样调整之后有没有问题。还有这边，我们这边要调整，应该是宽度。高度，同理宽度，高度。诶，那么我们可以知道这边 create pipeline 是在 subsystem 创建完毕之后，所以说这是更新后的值，对吧？再看一看还有，嗯，这边是要转换成这个是个 int 三十二，那么这边呢？我们就做一下 INT32 一个变换，其实也不用我们直接这样做，我们直接去到这，然后是 int unsendint。

OK，我们看一下，别出错了，是一个search，这边的话是 hit 出错了，那会不会在这呢？我们看一看，会在这里，就是在 initwindow 的时候。好，这边是0，我们就看一看 application 里面初始化有没有问题。OK，那么我们就这样做，我们首先要清理一下。好，清理完毕之后我们要在这个 initwork 里面，这边我们有两个函数还没调，对吧？我们把它独立出来 create command buffers，还有 create sync object，现在我们再调用一下。好，这样就没有问题了。OK，那么我们接下来要考虑一下重建交换链这一说，我们把它写到这里，我们专门留一个地方在这个重建，OK，写在下面，下面刚好是一个功能函数区，这边重建交换链。

为什么会重建交换链呢？当窗口大小发生变化的时候，那么交换链也要发生变化，对吧？那就需要做重建，因为它的大小发生了变化，那么交换链发生变化之后，它随带着谁会发生变化呢？那是不是像 frame 那么相关的view，相关的pipeline，那么还有render， pass 等等，包括sync， object 都会发生一系列的变化，对吧？那么因为这一系列都会是依赖于这个 session 最初的创建，包括说为什么说同学们说 sync 为什么会发生变化？那是因为我们重建交换链的时候会不会有一定的概率它的这个 frame 的count。就是我们这个交换链有多少个帧会发生变化？所以说它也会发生，是这样，好，那么我们在这边先写一个最简单的函数，就是叫做 clean up surface clean up。

好，那么在重建交换链之前，我们应该把相关的对象给重新的，就是给它清理掉，对不对？那我们还需要有一个接口，光清理还不行，还需要重建 recreate surface。好，那么我们这两个函数先把它拷过来，就到这application，我们先看一下主干逻辑，对于主干逻辑来讲，一旦窗口的大小，你比如说你拖动或者说你最小化之后，它会发生变化，那么在这里我们需要等待当前的设备里面的任务完，所以说必须有一个 device wait。

idol 那么叫 m device get device 诶，然后我们再去做 clean up，对吧？这时候才可以清理相关的资源，那么我们清理资源的时候，我们清理的是什么呢？首先我们要把 subchain 给做一下reset，把它里面的东西清理掉，它清理的时候会发生什么呢？来看一下它清理的时候调它的析构，对吧？那到这边首先 view 没了，帧缓冲区没了，然后自己的subchain，然后我们要去析构掉谁相关的command，对吧？来 command pool reset 一下，因为 command 也是跟 subchain 的数量相关的，对吧？那么接下来我们还需要搞谁诶？把 command buffers，对吧？ command buffer 应该是在。

这个 command pool 之前好，在这里我们来考虑一下，我们到底是要这样做呢？还是怎么做？你这样做的话你就相当于把整个 pool 干掉了，是吧？那么接下来我们的这个 command buffer 就自动析构了，但是这样做好不好？这样做的话其实并不好，我们还有一个是让 command buffer 自己去析构掉，那么怎么做呢？我们看一下在 command buffer 里面，这里我们并没有写它的析构函数，因为它会随着 command 析构把 command pool 析构而析构。但是我们如果想让其中一个 command buffer 死掉，而其他的 command buffer 不死掉的话，那么这边就需要调用一定的 Vulkan 接口来实现了。

在 command buffer 里面，我们这边是存了这个 command pool 的，对吧？所以说这个一定要先析构，一定要它析构掉之后，它的对于 command pool 的引用才能让 command pool 析构掉，对吧？所以说基于原理上来讲，我们应该这么做，如果 command buffer 不等于 VK null handle，那么这边需要 VK 叫 free command buffers，那么第一个参数是device。

第二个参数是 command port，第三个参数是它要析构的个数，我们就一个，是吧？然后最后是析构掉哪一个，那么最后是看一下 p command buffers，对，就是我们要析构的这个 command buffer，就是说一个这个 m command buffer，OK，一个引用。

好，这样的话如果这家伙他析构的话，他就会把自己干掉，那么我们完全可以这么干，在这边我们就不去做这个池子的析构了，我们不干掉这个池子，我们把每一个 command buffer 给干掉就可以了。怎么干掉每个 command buffer 呢？ m command buffers 直接把它 delete OK 就可以了。然后我们接下来再看一看关于 pipeline 也需要干掉，对不对？所以说pipeline。它也需要 RESET 智能指针， RESET 就是析构，是吧？就是重置。然后render，pass，reset，go，然后的话我们再考虑一下还有什么需要干掉的，还有就是它的同步，同步的各种东西对不对？就是 semaphore 等等SEMA。

And imagine available samples.

这 3 clear，然后是 m render finish clear，然后是 fence clear OK，我们先写这么多，然后回头我们再看一下有没有查缺补漏，然后在这 reset 的过程当中，我们先实验一下到底这样做能不能行啊？能不能真正的 reset 掉？能不能真正的它的析构函数啊？因为这毕竟是用智能指针，我们要看一看到底。

通过实践检验一下有没有一些奇怪的依赖，那么我们在这边通过 init Vulkan 完毕之后，我们就立马调这个 recreate surface，我们来跟一下，好，到这了，到这之后应该会进这，然后我们先看肾，它的析构函数，它的析构这里好走到了它的这个析构了，是吧？析构掉一个两个三个走，然后一个两个三个，然后这边走，析构，析构，哎，OK。那么。这边我们跳出来了，我们再剪一下，其他的我们都打上断点，在 application 这边都打上断点， command buffers 转到定义这样我们把它转到 command buffer 的析构这边打断点，然后我们再去看一看这个，打个断点 run 的pass，打个断点好，然后是 semaphore 等等，后面这几个我们就不看了，都一定会调用的。好，那我们再次运行。

好，首先 command buffer 是不是落码了，对吧？也被析构了，看一下进去，哎，这个析构并不是在内存级别的析构，这个只是说从 command pool 里面把这家伙给释放掉了，就这块内存不是你的，我回收到我的 pool 里面来了，好，哎，好。然后 pipeline 也干掉，好， F5 跳过来，那么这个 render pass 干掉， F5 跳出去，哎，就出现了问题，我们看一看这个析构到底哪里出现了问题，再回到application。

看是哪一步，哎，我们应该是这样子，我们应该先清一下工程，然后我们再跟一遍，好好清理，OK，没有问题啊。那么刚才这个出现问题的时候，那肯定是那个 loop 导致的，是吧？因为他引用了这一堆已经被清理的对象，我们清理完毕之后还没有去重建，所以导致了这个问题。没关系，我们主要是这节课的任务，主要是把它清理掉之后，我们还需要再重建它，而且清理的时间也并不是在这个地方，这只是做一个清理相关的实验啊。我们把这个清理的函数删掉，好，再运行一下，保证没有问题。OK，没有问题啊。

那么总结一下，就是关于智能指针这边是有一个引用计数，对吧？那么只有当一个对象的引用计数全部清成 0 了，它才会真正的析构释放，那么我们这样去做呢？其实在 Vulkan 的系统里面就是保证了互相之间有依赖 Vulkan 级别的析构顺序的对象是按照顺序去析构的，因为所以说我们其实在每一个对象里面都存储了它所依赖对象的智能指针，比如在 command buffer 里面，我们确实就存储了这个 command pool，对吧？就这个意思。好，那么我们这节课就到这里先带领大家写一个析构的这么一套函数。

