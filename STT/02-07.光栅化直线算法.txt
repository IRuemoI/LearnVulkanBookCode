02-07.Vulkan-光栅化直线算法

好，各位同学，大家好，那么这节课呢，给大家讲的是光栅画知识里面的画线算法如何在平面上画一条直线呢啊？
这个的话是图形学最基本的问题。
问题在屏幕坐标系下的二维平面当中啊，就是这一堆，其实是一堆离散的像素点，对吧？
那么如果给定了一条线的起点与终点，如何绘制一条直线呢？
我们看。
起点的话，其实是代表了某一个像素格，它的坐标一定是什么整数对吧？
终点呢？
也是代表了一个像素格，它的坐标是整数OK。
那么，我们如何画一条线？
首先呢，我们肯定想到的是直线的斜截式方程法，对吧？
在初中很简单的知识里面啊，就是直线方程y=kx+bk是由y的啊，起点与终点之间的y的这样一个差值比上起点与终点之间x的差值。
啊，那么同学啊，肯定会注意到啊，就是k啊，可能是一个float类型，也就是也就是是一个浮点数，对吧？
有带小数的那b也可能是一个带小数的。
啊，那么我们啊，把这个问题啊，已经抽象成了一个数学问题啊，这个数学问题的话呢，那么里面肯定就有啊，小数啊，什么无理数啊，什么这些东西对吧？
好，那么我们看啊，这个算法执行的时候怎么办呢？
是以x1为起点，也就是起点的那个x值啊，开始向终点的x值就x2进行固定啊，可能一个for循环是吧，然后每次呢x都加，一直到它加到x2为止。
那这个for循环里做了什么事呢啊？
它每一次啊x+1个单位都要带到这个公式里面啊，去计算一下y做标值那么很大的可能会算出来个什么玩意啊，可能算出来一个带小数的y。
对吧，带小和y所以说呢，要把这个y啊，也要去整对吧，那才能映射到一个像素格里面嘛，所以说呢，你要么四舍五入啊，你要么就是呃，把它直接丢掉小数部分啊，等等。
但是啊，这样的一个简单的算法，它期间涉及到了太多的float类型的成熟运算啊，性能很低下，我们想的是什么呢？
第一啊，只用整数计算，不要用小数啊，不要用浮点数。
这样会更快，第二的话呢，尽可能的多用加减法，少用乘除法，对吧？
那么，这就啊，迎来了我们这节课重点的一个划线算法，叫bracing ham算法。
那么，在我们之前讲啊，如何去构建一个OpenGL底层库啊？
这么一个模拟课程当中啊，咱们其实讲过这个bracing ham也给大家实现过。
在这里的话呢，就给大家把这个原理啊，也过一遍。
好布兰兹汉姆的核心思想是什么？
我们考察在二维平面当中的这四个像素点，每一个蓝色的点呢，都是这个像素点的中点。
我们给出坐标，这个为xi yi，那这个肯定是xi+1 yi，上面的话是xi+1 yi+1，就这么个结构。
那么假设呀，现在我们resent time算法，虽然还没学呃，假设它已经跑起来了，跑起来的话呢，刚好把这个点给点亮了啊，它是冲向这个方向进行画线的啊，冲向这个方向画线。
而且呢，我们现在其实也知道它的方程式对吧y=kx+b啊，也知道它的方程式，那么请问啊？
我们当从xi步进到xi+1的时候，我们应该选上面这个，这个像素格点亮，还是选下面这个像素格点亮呢？
因为我们发现啊，这个线既穿过了，下面这个格又穿过了，上面这个格。
对吧，那么我们的核心思想是这样的，先把xi+1这个地方的在斜截式方程里面的值给它算出来，就是这个y float。
这是一个数学上的值，对吧？
无法表达一个像素格，因为它带小数啊，所以说呢，我们接下来怎么办呢诶？
求得上下两个格子的中心点，距离这个y float的距离。
上面是第二，下面是第一。
如果我们发现第二比较小，说明什么？
上面这个格距离真正的y float比较近，所以我们就点亮上面这个格啊，我们就取这个坐标。
yi+1，如果下面这个比较小，说明下面的格距，它比较近啊，距离它比较近，那么下一个着色点呢，就肯定选这个格了，好这个就是bre sen ham算法的最基础的思想。
但是它最精妙的地方啊，是在于它去掉float，并且简化啊，计算过程的这么一个能力。
那么，在讲解bre sen ham之前，我们先做出一系列的假设，一直线的斜率是小于45度的，当然也要大于0度啊，就是说呢，这个是x轴，那么你一定要以逆时针方向向上旋转。
但是你旋转的角度啊，一定要小于45度啊，并且p1的xy值均小于p2的xy值起点的坐标值啊，它xy都要小于终点，这样也方便我们推导，那么我们把这一种情况研究明白了，其他几个方向的情况呢，推而广之即可。
好，那么接下来我们来正式看一下runs cap算法推导。
首先，直线的方程给出来y=kx+b，只要我们拿到了直线的两个顶点，是不是就能够算出来这样一个方程啊k对吧？
两边直接啊y相减比上x相减。
然后呢，再随便选一个点带进去，把b求出来啊，很简单。
那么第二步啊，我们要算xi+1点的y值y=k括号xi+1+b啊，带你去看一看到底这个xi+1这个地方，它的y float等于多少？
但是大家注意一点啊，我现在讲的这个只是说它的推导过程，而并不是说这个算法真正执行的过程，真正算法执行的时候是不会去算这个东西的，这个只是帮助我们推导的一个过程。
然后我们算一下yi到y的距离啥是yi啊，看一看哦，这个点是yi对吧，它到y flow的距离是第一啊，我们记得啊，下面这个点是第一。
那么d1等于肯定得用y float去减去yl，因为我们的假设情况当中y float是在yi的上面啊，所以这样减去即可。
减去之后呢，我们得到de，然后接下来呢，我们要求dr那么yi+1就是上面那个顶点啊，上面那个小方格距离y close的距离就是这个对吧，因为它在上面嘛，所以肯定是yi+1减去这个。
接下来啊，我们看一看这两个距离到底谁大？
我们直接用第一减第二，那么这两个啊式子一减就得到了这一堆东西啊，得到这一堆东西好，我们接下来是不是只需要判断到底这个第一减第二是正是负就能够知道取上面或者取下面这个方格了，对吧？
那么，这个判别式里面还有一个问题。
k可能是float，并且b啊，说不定也是个float，对吧？
那么我们先聚焦到k上面去啊，我们怎么把这个k啊变成不float的东西？
看一下这个k啊，其实是dy比上dx对吧？
其中dy和dx肯定都是整数值，这两个值是整数值，但是它俩相除呢，可能就是个float了，对吧？
那么，我们把刚才那个做出来的差呀，两边各自乘以dx就能消灭float了，对吧？
看一下哎，这边乘以dx这边里面呢？
都乘以dx，然后把dy暴露出来了，对吧？
那此时可能是float的含有b，但是我们并不关心它，因为在后面的推导过程当中，啊b会被干掉。
好，那么我们将这个判别表达式这一坨，我们称之为pi，为什么做了个pi呢？
因为啊，第一是简洁啊，直接让pi进去得了啊，第二的话呢，就是pi的正负可以代表选择哪一个y值？
因为dx 1定是正数啊，dx 1定是正数。
为什么它是正数呢？
因为我们在算dx的时候啊，就要先找出来起点和终点哪一个啊，更大一点，我们让大的那个去当它的终点，然后用终点啊，减去起点的x值，这样算的dx，所以说啊，它一定是正值，对吧？
呃，那么我们啊，每一次怎么求取这个pi呢？
这就是个问题了，好，我们现在整理一下啊，是不是我只要知道了pi的正正负我就知道了啊？
当x=xi+1的时候。
就是往下一个格看一下的话诶，我就能通过pi的正负来选择下一个格，该选哪个y呀？
对吧？
是这样好，那么我们看一下啊，选择pi+1与pi进行相减，从而尝试构造一个递归求值的办法。
啊，刚才拿到那个式子呀，真的是太乱了，我们把唉pi+1与pi- 1下，我们看一看啊，是不是能做一个递归的东西，出来之后我们就可以反复套用这个，用上一个pi求下一个pi+1啊，这样一个过程。
我们看一看pi写作上面这个式子啊，这个已经很清楚了pi+1呢唉，这边xi+1等于多少啊？
那就是往往前面不进一个嘛，就是xi+1。
那么yi+1呢？
不知道哦，因为我不知道pi的正负啊，所以我并不知道这个yi+1是yi+1还是yi啊，所以呢，就把它写作y+1就好了，后面这个头不变对吧，因为毕竟后面这个是定值嘛，不是变量。
好，然后呢？
把它俩相减一下，减完之后呢？
我们把pi拿到右边，这样我们就构建出来了一个递归啊，每次都用pi能算pi+1了。
好，那么我们想想啊呃，我们如果能够知道pi的正负是不是这个yi+1就知道该取yi或者该取yi+1了，对吧？
啊，那么倒推回去啊，我们只要知道了pi的正负也就知道了，它那么是不是也就知道了pi+1的取值了？
对吧，那我们看一下啊pi用来决定当x=xi+1的时候y应该取yi还是yi+1，那么只要知道了p1不就可以了。
对吧，我们知道了p1哎，我们知道p1的正负，我们就能知道什么yi加呃y2啊y2到底取什么值，我知道了y2知道了p1我就能取得p2。
我知道了p2就能的正负，就能够知道y3对吧？
我知道了y3和p2就能够取得p3啊，这是一个递归的过程，大家可以仔细思考一下自己在纸上画一画看看啊，这样一个递归的过程。
所以说呢，我们的问题就变成了如何求取啊p1，我们看看p1怎么取啊？
哎p1=2dy x1-2dx y1，加上巴拉巴拉这一堆x1和y1，我们知道吗？
是知道的，因为它是这个直线起点的坐标值。
好b，我们知道吗？
b当然也可以知道了，我们将起点坐标值带到直线方程里面，直接把b求出来了，所所以之后啊，我们把b带到这个方程里面。
哎，我们就可以求取p1等于什么了？
我们看啊，把这个b是不是换成这个式子啊？
就变成了这样，然后把这个式子展开，就是2y1 dx这边是2 dy x1，然后这边的dx就消掉了，加上诶这些小图。
然后我们发现诶，是不是刚好可以干掉他们啊？
这个跟这个变成呃零了啊，这个跟这个消去变成0p一非常简洁，等于2 dy-dx。
dy是什么呀？
不就是终点减终点的y值，减起点的y值吗？
dx是什么？
不也是终点的x值，减起点的x值吗？
诶。
很轻松，我们就得到了p1，而且呢，里面没有啊，这个呃非cos的乘法啊，这是个cos的，值嘛，乘以个dy减去个dx，这个是可以变成两个加法的，对吧？
啊就dy+dy，你看它没有乘法了，对吧？
它也没有float值了，我们算出来这个p1好，我们看一下，如果拿到p1之后，我们通篇这个算法就可以怎么去做了在这。
p1=2 dy-dx，这个是没错的啊，然后我们演绎一下，哎，我现在知道p1了，我现在看看它是否大于零哈，如果p1大于等于了零，意味着什么？
我们翻到最开头啊，第一减第二大于零，说明什么？
说明第二比较小，对吧？
第二比较小，我们选上面那个方格。
好，那么我们选上面的方格看一看啊，那么当p1大于等于零，那么对于y2来讲y2就可以选择y1+1。
对吧y1+1我们的y2就出来了y2出来之后呢x2肯定就是加个一就完事了嘛，因为以x为步径方向嘛，对吧，所以x 2=x一+1。
那么，我们接下来啊，就可以算p几了，就可以算p2了，对吧？
算P2P 2=p一+2倍的dy-dx，那后面怎么来的呢啊？
后面不是通过它俩的关系来的吗？
对吧唉，看看它俩之间有这样的关系啊，因为啊，我们选的上面那个点，所以说yi+1=yi+1 yi和对吧yi+1 yi和yi除。
去掉了啊，只剩下了一对吧？
所以说呢，变成了p 2=p一加上个2 dy- 2 dx啊，这边是个一了。
所以说大家看是不是这个道理啊啊，就成这样了，唉，我p2算出来之后呢，我这个循环还在继续回来，然后循环到这来，如果p2大于等于零呃p2结果发现它没有大于等于零啊，就跑到下面这个分值来了，对吧？
p2没有大于等于零，说明什么呢啊？
说明什么呢？
说明。
在求取第三个格格的时候啊，就是x=x一+2的时候呃，那个发现啊d1-d二是小于零了，说明什么？
说明是不是啊？
就不带大家回去看这个图了啊，就说明。
下面那个点下面那个格格距离咱们的直线更加的近啊，所以yi就等于y+1就等于yi对吧，所谓的就是y 3=y二啊y 3=y二了。
对不对？
那y2等于什么呀？
刚才不是算了嘛？
y 2=y一+1啊，对吧？
哎，所以它就相等了x持续不进，但是呢，下一个pi啊就是p什么呀？
p 3=p二+2 dy了。
为什么加2 dy呀？
还是那个式子对吧？
还是那个式子这边？
因为yi取的是y+1=yi了，所以说后面变成零了啊，直接加个2 dy就行了，所以大家看啊，通过这样递归的手段，我们不停的循环，一直到x步径到x2为止，这个算法呢，就能够把点全部画出来了。
而且里面呀，都没有任何的这个浮点数的运算啊，也很少见到很大面积的乘除运算，对吧？
好，那么这个算法呢？
希望大家能够消化理解，并且自己实现一下啊，然后呢，如果实在不明白的，可以去到我们那个啊。
呃，就是用C加加构建一个喷漆到底层固定的一个课啊，也就是我们的这个冷光山课程，好好去学习一下，但是呢，对于我们这一系列课来说，大家理解这个算法即可OK？

