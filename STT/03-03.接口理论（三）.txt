03-03.Vulkan-接口理论（三）

啊，我们先做一下前情回顾啊，因为呢vulkan这个东西啊，比较零碎，我们要时常总结，首先我们知道啊，要做一个instance对吧，它保存了程序的原数据信息。
然后呢，用instant我们可以创建一个什么呢啊，把broken的这个实例啊，与我们的窗口关联起来，这么一个surface，然后呢，我们再用这个instance啊，作为一个索引啊，或者是说作为一个身份，我们去到机手里面啊。
去找到一张显卡啊，我们挑一个，挑完一个显卡的硬件设施之后呢，我们去了一个logical device啊，就我们能够远程来控制这个physical device。
然后啊，我们用这两个东西啊，去创建了swot train，因为swot train啊，它又要兼容surface的，这样一个表面结构啊，它的一个格栅特性啊，然后啊，又要让去兼容这个logical device背后的这家伙。
其实它兼容这个logical device主要还是透过logical device去兼容这个啊，兼容它后面的显卡，然后呢，创建出来sw ptr and它，同时呢，会为你创建n个啊，不应这三个n个offer。
这个块呢，其实也属于我们device里的特性啊，到底能创建多少个缓存？
随后，我们讲pipeline在pipeline里面呢，我们可以设计一个管线，这个管线呀，我们可以放各种各样的水进去，把它流过，也就是说呀，我们可以放各种各样的模型，然后。
送入这个管线进行渲染，那么我们可不可以把这个管线理解成为一种什么呢？
是一个类似于模板的东西啊，或者说把这个管线就理解为一个函数，谁都可以调用它，谁都可以往里报。
然后pipeline呢，就设置了这个管线里面的所有的行为信息，包括你画成三角形也好啊，然后你使用什么样的呃shade啊，使用什么样的着色器啊，你使用怎样的透明啊，是否要启用深度啊等等啊OK？
然后呢？
我们知道啊，要有render pass，而且pipeline啊，在market里面还是render pass相关联的，也就是说render pass也会作为一个参数传入到pipeline里面。
那reno pass它做了什么呢？
它是规定了啊，你们这个这次渲染它分几批次渲染，每一次渲染得到的结果是否要输入到下一个批次里，最终啊，经过几次的渲染叠加效果，从而呈现到屏幕上。
那么，管理渲染批次就是伦敦帕斯？
okay，我们现在呢，给出一张图，接下来啊，我们就要介绍新的东西来丰富这张图表。
那么，接下来我们探讨一下，在v里面如何去描述vertex？
就是说白了，描述我们的模型。
对于一个顶点来讲，我们说上面有属性，那么什么呢？
当然可能是什么position对吧？
也可能是它的颜色color，那么我们通过前几节课的学习啊，就知道只要我把这样一个vertex啊，把它的特点输入到管线当中。
首先呢，它会经过什么vertex shader的空间变换，然后呢，它会被离散成一堆的像素点，那么这一堆的像素点上面呢？
每是不是每一个顶点都有颜色，然后经过差值被离散成一堆的不同的颜色，散到这个像素点里面。
然后呢，相同点再从再从500米的谁那来进行处理输出到屏幕上，那么关于顶点的定义呢，就可以直接在我们的程序里这样去写。
随后啊，我们要为它在gpu里面开辟一块显存，然后呢，对这一堆顶点进行存储啊，那么这个就是work buffer。
啊，这个work buffer的话，在呃创建出来之后呢？
会在这个gpu端存续，除非我们删除它。
随后，我们要考虑我们要怎么去描述这样一个顶点。
那么，我们知道啊buffer里面是存了一堆的，对吧？
一堆的这样的点，你也可以理解为一个顶点数组被整个拷贝到了这个buffer里面。
那么，为什么会有有一个叫做binding description的这样一个描述的东西呢？
因为是这样子啊，我们还有一种做法，比如我把vortex拆成两种数据结构。
一个是它的position，一个是它的color，那么position我可以存对吧？
我把十个顶点的position存到一个数组里面。
我再把十个顶点的color也存到一个数组里面，这样我就拥有了两个数组，那么我就要开辟什么呀？
我开辟两块显存，一块来存所有顶点的位置，一块来存所有顶点的color。
那么，这两个v buffer我们就可以拿到，拿到之后呢？
我把两个v buffer啊，把它放到了一个什么看这里，所以给送入管线的传入的可能是两个buffer，那么会合成一个数组进行传入管线。
所以说呀，我们要对每一个八分进行编号，那么就是它的索引，那这个编号啊，其实就是它在数组当中的那个索引啊，零号一号啊，这样子。
OK，那么这就解释了，为什么要有binding description这样一个啊，需求那么接下来呢，有一个东西是attribute description，哎，又来一个啊，它是完全跟binding不一样的一个结构啊，那么。
假设我们再回来啊，到了这样，假设我们就只有一个work buffer啊，当然这一个work buffer呢，是不是自己组成了一个数组被传进来，那它的bending description是多少啊？
就是零对吧？
直接到这一个数组的第零号位置去取这个buffer。
OK，那么这样的一套定义方法的话呢，就必须要用这个execute description来进行解决一个问题，那就是对于每一个顶点来讲。
那么position是在一个什么样的位置上，它搬定到哪一号，我们知道sheet r当中啊，由于每一个顶点它的信息啊，是被单独传到我们的vertex shield r里面的。
那传到我test里面之后啊，它会接啊，接收每一个顶点的position和color。
那么我就需要描述一下，在这样一个数据结构里面position，在这个数据的什么位置啊？
对于单个顶点来讲position在哪？
color在哪？
所以说我们看啊，这个h就是来描述这个点的，在程序里我们可以看到啊，所以我们总结一下啊offer是存放了所有的数据密集的财富啊，密集的可能存放十个点。
然后对于每一个点来讲，它是里面的一个小段，那么这一小段内存呢，有可能会包括两种信息，一个是position，一个是color，那么这种描述是在哪里描述的呢？
是在attribute description。
那如果说顶点把它拆开了，比如把顶点的position放成了一个数组，把color放成了一个数组，分别生成make buffer，那么这buffer呢？
组成了数组之后就需要传输管线，那是通过什么来索引的呢？
通过顶点的这个de biding description。
在手里好，那么这些东西我们都会在程序里面一一实现。
接下来index缓冲啊，顶点的所有大家都知道什么了，我们之前解过啊，解释过，所以顶点呢，其实是这样一堆数据，那个构成一个三角形对吧？
那么这里的所以呢，就是构成几个点，构成哪几个点啊，构成三角形的描述。
那么，这个很简单了，我们只需要把顶点索引干嘛呀？
哎，直接放到这样一个八块八块就可以了啊，所以顶点也是个一二八块里面。
那么顶点的话呢，我们怎么分割呢？
这是一整块的数据啊，所以说我们在压入把斧之前啊，加入把斧调动当中啊，我们也会告知说我们每一个啊，每一个索引是一个什么类型，是一个int还是一个int 16？
对吧，然后呢，我们就可以让它的大小进行切割，一个一个的切出来进行识别好，那么接下来我们介绍command buffer对于command buffer来讲啊，那么它就是我们核心的问题，核心的东西之一了啊。
command buffer用于存储本身，绘制所有的元素啊，比如pipeline的选择啊，render pass的选择等等啊，所以command buffer是一个绘制指令，它会告诉我们的wal CON的啊，这样一个驱动啊，说我现在这帧绘制需要用到哪些的信息？
需要弄到哪些的设计？
需要做哪些事情？
那都可以写在这个command的版本里面。
它分为两种，一种叫primary command buffer啊，就是它是直接可以提交到选员卡线的，第二种叫做theory command buffer，它呀，需要提交到primary里边啊，它是提交到它里面去的，然后再由它一起提交进去。
那么我们看一下啊，首先呢，会有我们通常会这么做啊，给每一个物体啊，给每一个单独的呃模型啊，我们会生成一个三个女人come offer，然后由我们一个便利循环当中，会便利每一个单独绘制的物体。
然后为它填充它的secondary command buffer，然后呢，把这些物体都填充完毕之后啊，我们会统一提交到primary command buffer，然后呢，提交到任务队列进行绘制。
那这个过程叫什么叫draw call啊？
我们在做游戏或者图形优化的时候，经常会很多draw call，很浪费时间，为什么费时间啊？
主要就是构建command buffer，浪费的时间。
那么，如果拆成secondary command buffer时候，就可以进行多线程的buffer构建，每个每一个secondary command buffer都可以成为一个线程，然后多线程构建完毕之后，然后归并到主线程，加入到primary command buffer。
这个就属于扩展性的课程来讲啊，好，那么我们汇总一下。
首先，渲染准备的条件有这些instance physical呃device surface，oracle device，social change等等，然后呢，我们要准备pipeline red pass。
再然后我们需要准准备顶点顶点的buffer，在这顶点的description bending description attribute description，然后把这两个描述都与pipeline挂钩啊，就是要告诉pipeline我这么排布的。
pipeline知道之后呢？
我们接下来就要提交了，然后我们做一堆的为每个模型做一做一个什么secondary command offer，然后呢？
我们需要把pipeline和rand pass设置进去，告诉用命令的形式，告诉我们的圈，告诉我们的穷啊，我要用怎样的管线，用怎样的rand pass。
随后，我们还要告诉告诉我们的啊驱动，说我要用哪个啊，我要绘制哪个顶点法。
然后把这一堆都提交到primary command buffer里面啊，当然这边也会去提交index的buffer啊index buffer，但这没话了啊，好，我们把所有命令都提交到primary command buffer之后，我们就需要向渲染任务队列里面提交命令。
把这批次写进去，那么选这种对列呢，就会一个一个的执行，这里面的command那完成一个的渲染，就会输送到buffer里面，那buffer自然而然就会通过我们的呃buffer的形式，对吧？
来我们的垂直。
呃，就在我们的这个屏幕上面啊，进行解释。
OK，这就是我们整个啊，这个login最基础最简单的这样一个啊，调用的结构。

