11-06.Vulkan-多重采样图片构建

我们这节课呢，是制作啊，我们的抗锯齿的部分，那么首先呢，我们在我们的device这个类里面，我们要获取到我们当前的设备，到底能支持多少的抗锯齿的这么一个数量？
它是一倍抗锯齿，就是补充的嘛啊采样为一还是说四倍八倍16啊64等等OK，那么我们把这个变量啊，先给它找个地方存下来。
我们把它放在啊，这个private变量找个地方吧，在这边啊。
抗锯齿系数OK，它的一个类型是vk sample，然后count black bits。
诶，这么个东西，然后我们给它称为啊，叫sample counts。
它的默认赋值是vk sample count 1啊，我们只采样一个OK，就是不抗锯齿啊好，那么我们接下来就要去找一个函数啊，做一个函数来，专门去找到这样一个变量啊，给它进行赋值。
那这个函数呢？
我们把它放到这里吧。
呃，它返回值是vk sample count flag its。
那么，做get max usable sample count？
okay，这个函数很简单啊，我们直接去呃，实现一下它。
把这个冒出来。
okay.那么首先啊，我们要拿到什么呢？
就是物理设备的性质啊，因为这个东西啊，是属于物理设备的性质，叫vk physical。
我们之前也接触过这个变量啊device properties。
这个东西props。
OK，然后呢？
make it get physical。
呃，pro device practice。
OK，然后呢？
我们传入啊，这个property这个我们的物理设备physical device，然后呢？
我们再传入一个这个props。
那么，所有相关的东西啊，就被我们获取到这个pro里面了，最后呢，我们要拿到位example count flex，这是个什么东西呢？
count等于。
好，我们先看一下里边的类型啊。
OK，它其实就是这一堆啊，这一堆数字对吧？
其实就是一堆数字，那么这堆数字呢，就能够进行比大写了，我们要找出来，我们能用到的最大的那一个啊，这个东西怎么找呢？
我们需要这么找sdd命。
OK是什么和什么之间的最小呢？
props limits那么叫做frame buffer color sample counts。
这是一个对吧？
也就是说我们如果把当前的图片作为一个frame buffer里面的一个颜色的啊，专门用来输出颜色的这个地方的话，它最大的这个三报counts诶，它到底是多少？
那么我们这种可能是要把它这张图片当做什么呀？
是不是当做深度模板对吧？
所以说它的limits里面应该会有一个frame buffer depths诶sample counts对吧？
这个东西。
好，那么我们现在找到了，我们能啊，这个系统里面能用到的最大的这么一个啊，所以说最大的这么最小的这么一个，我们采样采样的数字啊，采样的数字，那么我们接下来呢，就要把它与。
各种可能性进行对比，如果啊，它是vk sample count 64 bit的话，那么OK啊，我们就给它return就好了，return呃，那么这个vk sample count 64 bit。
给它搞过去好，然后依次进行啊，我们一定是从大到小，对不对？
因为我们现在想获取到的是max，对吧？
那这边呢？
就是32，然后这块呢？
也是32？
然后呢，接下来我们要看一看除以26。
16那么这边呢，也是return 16。
诶，然后就是八四二啊。
八四。
二哎呀，这个东西挺多的。
呃，嘿。
嘿啊好。
如果它连二都不是的话啊，那么我们没办法了，最终对儿vk sample count一个bit啊，我也就不去做什么OK，这样的话，这个函数就完成了啊，我们现在获取到了关于设备里面的东西，之后我们接下来要干什么呢？
啊，我们接下来要开始在图片创建上进行动手脚了，我们看一看啊，以前的图片创建的话呢，我们已经保留了相应的字段啊，我们看一看print里面是有一个三泡这么个东西的啊，是有一个三泡的好。
那么，我们以前的这张图片的创建模式啊，大家还记不记得呃？
我们现在屏幕上，桌面上所看到的这张图片其实是什么呢？
其实是呃，我们的交换链。
自己产生的一张图片，对吧？
交换电自己产生的一张图片OK，那么我们现在呢？
就要去手动产生一张图片，让它呢？
把这张图片渲染到把这个内容啊，渲染到这张图片上。
然后啊，咱们之前说过啊，是需要resolve到这个我们的原来那张图片上的，也就是说我要在我们渲染的这个过程和s中间插一张图片高分辨率的，对吧？
也不是高分辨率，是高采样率的啊，高采样率的图片。
然后呢，在result上面去，那我就在这边啊，需要加一个工具函数了static image ttr那么叫什么呢？
create the render target。
image,okay.那么，我们先把这个上面的这些东西先拷过来啊。
诶，好，那么我们看一看，一会写的时候看看这家伙到底他需要什么样的参数，对吧？
先把它拿过来，我们要开始写了。
好把image的帽子拿过来。
okay，好，这边呢，我们是不需要像啊，这边这么搞的这么复杂的啊，我们其实只需要在这边做一个生成image就可以了，然后return到它。
但是在这边呢，还有一个问题啊，因为我们在这是获取了这个，我们在这边获取了深度的format对吧，所以在这边呢，我们关于这种color的format呢，我们是需要它从外界给传进来的啊，所以OK我们转到定我们转到声明看来我们需要加的。
第一个参数诶，这个声明没有没有转过去啊OK，这个我们就转过来了，那么我们第一个要加的参数呢？
那么肯定就是它的格式对吧？
所以这边。
好vk format诶vk format format。
好，把它拷过去。
到这里。
okay，我们直接做了一套。
呃，return一个什么呢？
return一个image。
啊，这个上面image。
create一个一个的把参数填上，首先device。
好，其次是它的宽度高度没问题，都填上，然后呢？
是它的format哎，我们传进来了，然后是它的这个aspect。
类k image type rt。
然后是它的tiling啊，我们都把这个都抄过来吧，先都抄过来再改啊，然后tiling没有问题啊tiling就是它的usage啊，它的usage那么我们的现在的usage是什么呢？
诶，把它去掉。
ok，那么它现在的usage呢？
肯定就不是什么啊，深度啊，什么什么东西了，对吧？
哎，而是还是一个vk image usage color attachment bit啊，它是作为一个color attachment。
诶，扔在了上面了啊OK，然后呢，我们再看一下它的sample count 1，这里就有问题了，对不对啊？
这边的话呢诶，关于上面这个参数啊，再给大家多个嘴啊，这边。
呃，多久对吧？
叫给大家几个小vk vk。
image呃叫做usage transcendent attachment呃bit这个地方，我把注释给大家写到这里啊，大家可以自己回去作为一个扩展的课题去学习一下。
这个也是蛮有用的一个东西啊，这个属于什么呢？
与呃，那么当图片拥有这个标识的时候啊。
会发生什么呢？
那么只有真正使用到。
使用到本图片的时候，才会为其创建内存那么显性。
诶，显性的调用内存生成是会lazy的。
什么叫lazy呢？
lazy就是说你用到我的时候真正去调用的时候，系统才会为你生成啊，所以。
所以一旦设置了trans cent。
就必须在内存生成的时候，也就是说啊，时候也就是说我们的这个叫device memory啊，生成的时候呢，加加一个呃，这个加一个参数叫做。
lazy啊，就是lazy，就是它的memory property lazy啊，需要加这个参数OK，那么我们现在呢？
是要直接生成它啊，所以说我们也不需要做lazy的这种内存了啊OK？
那么，接下来我们看sample count这个地方从哪弄呢？
就是从我们的device里面啊，我们再回去这device啊，就需要补一个接口了啊，刚才没有写OK device这边的话呢，我们已经有了这个对吧？
有了这个，那么我们就把这个接口拿来直接用吧，也不用补了，对吧？
呃，这个抗锯齿系数的话。
我们先去掉吧，我们直接去调用得了啊，也不用去记录了啊，这样还挺麻烦的，我们到这来直接用s。
get next usable啊啊，simple count bit啊，simple count OK，然后这边我们是property as local bit，可不可以呢啊？
可以的，它确实是local bit，因为你们要从CPU端去访问这块内存的。
同样啊，这边注意啊，注意如果上方用了transient，那么这里就需要加，也就是说就需要与吧与运算的什么呢？
我们进去看看啊。
云算一个叫lazy的东西啊OK，我找一找呃coherent host cash就是这个啊，lazy ly allocated a bit在这里给大家注释上啊。
哎，到这个啊lazily allocated it使用到的时候才会去分配内存啊，这个意思，然后呢，这边是它的aspect啊，刚才说错了啊，这边啊，不是啊，这边是它的类型，这边才是aspect啊。
okay，那么这边的aspect呃，那么应该是什么呢？
名叫vk。
AK image aspect啊，它是一个color bit啊，我们要用到它颜色的部分好，那这样的话一张可抗锯齿的被渲染的目标图片啊，并且有这样的三炮count的，那么我们就给它做好了。
那么在这里呢，最麻烦的一个地方就是刚才给大家写的这两个注释啊，关于lazy生成的这块呃，很多同学会问说这个东西啊，到底在哪里用啊？
这个东西呢，其实是在于你有的时候要关掉抗锯齿，有的时候呢，要开启抗锯齿。
但是呢，整个代码一套下来啊，那它都是呃，可能都会去给你提前生成这张图片的，那么你虽然生成这张图片，就是说你掉了，我就create这个函数啊，那么。
但是呢，我这边因为加了这种呃transient临时呃，然后就老了，就加了这种lazy ly allocated，那么其实我是不会立马去维系生成显存的呃，可能只有在你开启抗锯齿系统发现，就是老板发现你真正在用这块儿的时候，那么它就会给你去生成一次，生成之后后面就继续使用了。
啊，这么个意思，那么接下来我们还要看一个地方啊嗯，在这边的话呢，我们要生成的是一个啊，是不是要生成一个color touch ment bit对吧？
这张图片是被用来作为一个什么呢？
一个拥有多采样的这么一个渲染目标的啊，会渲到这上面去。
再result到我们的上面的图片OK，那么在这边的话啊，它的图片格式就会从undefined变成某一个layout，对吧？
变成某一个layout。
我们之前使用图片的时候啊，大家看一看啊。
这里在里面这个料子，我们可以说几种框对吧？
我们因为啊，要去做一个图片，就是说一个纹理，要去接收读入的图片，通过staging buffer去转到我的纹理上，我因为这样的需求。
所以说呢，我才把我的纹理图片设置成desktop对吧？
所以我们当时才写了这样一个东西，那么因为我们呃，需要把这个图片呢，就是说让它变成一个，可这个share可读的文。
哎，那么我们是不是又做了一个这样一个东西啊？
做了一个同鸟飞毛的，一个转换，因为我们要把某张图片给做成呃depth，就是说深度缓存所用的图片，所以我们做了这样一个转换。
可能性现在呢，我们要把它变成另外一种layout了，那么这个诶那么这个layout是什么呢？
这个layout就是color attachment optimal的，这么一个layout。
那么，我们是不是要把它再进行一次增加呢？
一种可能性的增加啊，因为我们一会儿啊，可能要去在外面函数生成这张target，然后呢，再把它转换成我们所有的color开始本它，或者我们直接就转了啊，我们看一下怎么做啊？
首先case vk，如果说你要把它转换成image layout。
什么呢？
color attachment optimal，如果你要给我转换成这个类型。
诶诶，怎么这么远呢？
okay，那么我的image memory barrier。
它的desk access mask，这应该是谁的呢？
我们想想这张图片呀，它应该是是undefined对不对？
那么我现在要把它转化成。
它那儿抬什么呢？
optimal那么请问那肯定就是在哎，这个shadow最终的fabrication要向其输出图源的时候再做了，对不对？
那么它向它输出图源就是说要向它上面写东西了，那么一定是。
向它上面写东西的这个操作需要等待这个layout的转换完成，是这个意思，那么就是类k access or叫做color attachment。
呃，right bit？
OK，就是说这个需要等待这个完成啊，这个需要等待其他的转换操作的完成。
OK，那么就加上这个。
好，我们再上来，我们又上来了啊，这个函数比较已经开始比较多了，大家呢？
建议还是要对着代码慢慢看，慢慢做啊，好那么到这边我们就全系列的东西都生成了啊layout的转换呢，我们还是在外面做吧，这边我们生成一张图片，在外面去做它。
OK好，那么关于这节课的内容，我们再捋一捋，第一，我们通过device，我们获取到了最高的是不是啊？
三号bit，它的采样数，然后呢，我们还做了一个这么一个静态函数啊，这个static函数，它用来生成一个全部标用的图片。
那么，我们需要传入的就是多了一个format，所以说在这边我们给大家提供了一种可能性，你可以做lazy内存的创建，然后呢，我最后我们在这个set image layout的地方，我们加一种可能性诶，这个图片可能会被set成这样的一种类型的图片。
那么，它需要卡住的那个操作，就是把它给我卡在这等着好，那么这节课的内容就到这里。

