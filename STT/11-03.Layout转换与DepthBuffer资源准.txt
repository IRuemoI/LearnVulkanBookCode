11-03.Vulkan-Layout转换与DepthBuffer资源准

各位同学大家好，我们这节课呢，接下来的两个问题啊，第一个问题呢就是我们要修改一下set image layout这个函数啊，我们让它呢，从一个undefined image。
把它变换成了一个啊，专门用于深度的image的l，那么这个地方的话，我们这个barrier的依赖怎么去写，然后第二件呢，就是我们需要修改frame buffer以及soap chain里面，我们要给它加上这张纸。
OK，那么我们先看一看原来这个set image料的啊，我们复习一下这边的话呢，我们看啊它呢，如果说它原来是一个这个，那么我们就啊，不等它任何的输入的过程，就上一个过程当中的操作，那么如果是这个就这样做，对吧？
这边的话呢？
就是如果。
啊，它是要目标是要转换成一个这个啊，那么我们在这个需要哪个过程当中需要等待上一波的什么时候完成，对吧？
需要等这个造槽完成才能完成它。
OK那么我们先啊，把原来的函数整理一下，这边有一个问题点啊，这个问题点的话呢，我们需要注意怎么回事呢，我们先给它打上个括号啊。
好，那么在这边的话呀呃，我们这个就是个题外话了啊，在这里对这个wrapper做一个修善啊，这边呢是这样的，如果啊，这张图片是要转换成为一个被纹理啊，来阅读的g share with only optimal。
那么它以前啊，它的来源只能有两个东西，对吧？
我们在这写啊，如果作为啊，这个t。
那么来源啊，只能有两种，一种是通过map从CPU啊拷贝而来，一种是通过啊，这个stating buffer。
拷贝而来，对吧？
就这两种东西啊。
那么我们之前啊，一开始做一个图片的时候，它是一个undefined一个格式啊，这么一种格式，那么undefined这边为什么就是它的source access 1定是零呢？
那是因为啊，我并不知道这个东西啊，它接下来会被发生什么样的操作？
那么我自然而然也就没办法啊，给它一个给它一个source access了对吧？
但是如果说我现在知道了它接下来要被转型成这样一个she单位的only。
那么我就知道了，在转型之前啊，那么一定要或者说大概率啊，会做这样的两种啊，两种操作的可能性。
那么也就是说呃，在这里再给大家澄清一下啊，说的详细一点啊呃，如果它是ID find的话呢，它能不能被直接过来转呢？
其实也是可以的啊，那就没有拷贝这个操作了，对吧？
那如果说它是先把数据拷贝了，要么是这种，要么是这种，然后再去转换，那么我就得等待它啊，拷贝结束，要么是host拷贝操操作结束，要么是这种transfer的拷贝操作结束。
okay，那么我们就以防万一啊，在这里我们就写一下，如果这家伙的。
四号色的塞斯马斯克如果是零的话呢？
我们就不能了啊，我们让它等于这个。
等于vk access。
那么host right beat这个就对应着啊，从CPU拷贝而来map掉啊，那么或一个叫做access。
呃，看一下。
vk access叫做transfer right bit啊，也就是说对应的这种啊，这种不是通过transfer的这个这个队列来进行嘛，对吧？
所以说就这个transfer right bit，我要么等待从这个CPU端拷贝完毕，要么等待啊从这个station buffer copy完毕。
那么同学说啊，这个如果它上来就呃没有拷贝数据，直接来转化了呢，也没问题啊，那么这两个阶段是不是就被啊忽略了，或者说这两个就变成了就是呃没有执行什么事情，直接就过去了是吧？
okay，那么我们在这里再加一个阶段啊。
break在这边。
那么，接下来case我们接下来呢，才开始真正处理，如果它是啊深度的话怎么办啊？
这深度的话呢，就是如果它是为k。
那么image layout steps sten SIL。
选手呃attachment optimal啊，就是说如果说要转换成这种歌的话，那么请问啊，要发生什么事情？
那么，我的这个目标啊，就要变成在哪个阶段等待呢？
我们都知道啊，这个录缓存是用来被写入的，对吧？
那么，在转换完毕之后，才允许它被写入这个深度值OK，那么我们就是写入这个操作需要等待啊，写入操作需要等待OK，那么这个写入操作叫什么名？
vk呃access。
depths tanti al attachment right bit啊，就是在转化完毕之后，那么才能够去写。
OK，那么这一块我们就啊给它加完了啊，也做了一些关于以前的这样一个东西的修改和防御啊。
那么好，我们接下来去到s。
所不称这边呢，我们看到啊，以前啊，是不是做了一个这样的一个image和image 6色对吧这边？
那这边我们又有去做托管到我们的这个应该之类里面管理的原因啊，就是因为这个应该只是从搜这里面获取的啊，不是我们这样啊，自己挨个给它出来的OK？
那么，接下来我们先把这个东西弄进来。
image.然后啊，我们在这边啊，要给它增加成员，增加什么成员呢？
增加下一个东西啊。
深度图片。
stv vector image.一点二叫做depth images。
okay，那么这里面呢？
就存在着我有多少个交换链的这个buffer，那么我需要升为每一个buffer来生成一个depth image。
好，那么我们去看一看啊，复习一下so PT on怎么做的？
在构造函数的里面的时候呢啊，它是在最后来获取了image对吧，并且有match count这样一个参数啊，那么这边我们在这写创建啊depth image。
OK，那么我们首先把depth image这样一个数组resize一下，resize乘多大呢？
就这么大对吧？
有这么多张，然后呢？
我们for一个。
小于image count。
好，然后嗯诶。
它的第I个应该等于image great depth image是吧？
然后这边我们能拿到device，这个device呢？
就是在这里面啊stop change里面带的。
OK，然后拿到它的宽度和高度啊，宽度和高度是什么来着？
我们看一下有没有accident，有没有哎？
没有啊，那这个宽高是怎么获取呢？
我们看一下上边。
诶，好这个啊accident。
okay，我们是存在这个变量里面了啊。
s accident呃，okay，现在回来。
它的宽度，它的高度。
好诶，你看这个工具函数是不是很好用是吧？
经常啊，封装些这种工具函数呢，其实对我们代码整洁性和易用性啊，都是有好处的啊OK，那么我们现在depth image也传递了，但是这个depth image还没有加入到我们的frame buffer里面啊，那frame buffer在哪呢？
唉，是不是就在这呢？
对吧？
great frame buffers好到这儿来，给它加进来啊，看怎么加呢？
这边有个循环啊，有多少个image是吧？
小循环为每一个image创建一个frame buffer。
那么，这样的话呢？
就是它的touch ment这么一个集合，但是呢，原来只有一张对吧？
那么我们现在诶还有一张需要给到它，就是dex images的第r一个。
那么这边需要。
get ss images，嗯。
okay，这边every应该是两个了啊。
好get也是view。
唉，那边传入的是image view啊，这边是image好，那么这样的话呢，它就被绑定到了一起，在一个二倍里面，然后呢，它们会被一起送到这边是吧？
这个创建参数这边。
等啊。
然后呢，就创建成了一个啊，这个frame buffer就是这个啊，所成成free buffer点下一个OK那么好，这课呢，我们再总结一下啊，这个首先我们在image里面，我们做了layout的转换，补了一个。
啊，这样的这样的这个depths stencil optimal optimal这种layouts的转换，然后呢，我们又做了这样一个修善啊，关于sailor read only optimal的一个修善。
然后呢？
我们又去到了sub chain里面去做了sub chain相关的增加啊，给它增加了，然后呢？
还把它加到了我们的frame buffer里面，那么这下这样呃之后的话呢，我们其实呃就剩下了关于。
还有啦，还有renda pass啊，这俩东西的改动OK，这节课就到这里。

