05-03.Vulkan-Shader语言与Spirv

我们呢，现在进入pipeline里面的第一个环节啊，就是shader那么相信，大家都知道啊，学过安琪儿的同学啊，都知道shader呢，其实就是一门gpu着色语言，对吧，然后它呢，是在gpu的可编程管线当中。
相当于输送给某些阶段啊，特定阶段的处理的逻辑程序，就比如我们之前介绍的对吧，顶点它被vertex sheet r那个阶段给处理了。
那么，给处理的话呢？
它就是主顶点的处理，对每一个顶点做相同的，谁的程序的操作，然后呢，它就会被呃离散成fragment，那么会输送到fragment shader里面，当然shader呢，中间还有很多步骤啊，比如说像几何shader啊，曲面细分计算shader等等吧。
那么，我们在这节课里面最主要型的还是五个test顶点，谁的fragment图源处理谁的啊？
那么glsl啊？
这个是在OpenGL这个标准之下的一个着色器的语言，它属于类c的语言。
啊，属于类似于语言，这在我们以前看到过。
那么，所以每家的显卡厂商呢？
都是要实现对于这个lsl的编译与支持，但是由于啊，这个glsl标准一直在更新迭代。
而gpu的驱动质量也不一样相同啊，新的扩展就有可能出错或者崩溃啊，甚至不支持，那么在这种环境之下啊，那么提出了一个叫斯波威的一种标准，它进一步的达到了驱动层。
也就是说呢，原来啊，我们编程是写glsl是吧？
然后呢，由我们的OpenGL程序读入这个glsl的文件，然后呢，在OpenGL当中对它进行编译与链接，最终生成一个中间的机器码输送给我们的显卡。
然后显卡呢，再进一步将它转化成机器的指令来进行运行，但是斯波威呢不一样啊，斯波威呢，它是使用了二进制格式的语言啊，是一种二进制格式自解码。
它的可扩展性跟机器的兼容性有了很多啊，毕竟不是一个类似于的语言，对吧？
那么市面上呢？
基础的11代，比如glsl，它都可以通过转换器叫做啊，比如说glsl啊这样一个格式上面。
这样OK，那么我们看啊，在谈到share的时候，第一个share就是我text share，那么这种顶点处理share最关键的是什么呢？
就是它的坐标系对吧？
坐标系。
那么，在walk当中，它的坐标系跟OpenGL是有区别的。
我们看OpenGL它的这样一个世界，坐标系是长这样子z轴冲向屏幕yx轴向右边y向上方就是一个右手坐标系，对吧？
我们以前讲过，对吧？
拇指大拇指啊，右手的大拇指冲向x轴，然后你的食指冲向y轴，然后呢，中指冲向z轴，那么就是右手啊，是右手的坐标系，那么我们看z轴是冲向门脸的。
那么，在这样一个lock里面变成这样，它把y轴给反过来了啊，具体什么原因，其实各各家的说辞不一吧，好不好啊？
也都有评说，我们这儿不做评论，然后呢，但是就是如果我们想使用这样的坐标系的话，后面我们可以开启一个扩展。
啊，写一个老版的扩展，然后后面会给大家去做啊，这样子。
好，我们这节课的目标，首先呢，编写一个模拟的g sig lsl shadow，不需要传入顶点，也可以绘制三角形，我们之前虽然讲啊，在pipeline里面是可以传入顶点相关的描述啊，但是我们这次先把这个。
三角形画出来啊，再把它更换成顶点的模式，这样便于大家理解啊，所以我们就要做这样一个sheet，第二，我们把sheet变成sv啊OK。
那接下来我们去到我们的这个文件夹。
这里呢呃，我们准备诶lesson 5是吧？
lesson排版。
在这里面呢，我们做一个文件夹啊，是字。
okay，那这里面呢？
我们做。
几个文件啊？
做两个文件，一个是叫做。
lesson shader word啊，通过text shader主顶点处理了，然后呢，我们再做一个lesson shader flag啊。
主片源的。
然后呢？
我们现在啊，用编开编辑器写一个。
okay，首先我们写我tab值点。
现在的语法呢，网上有很多教程，还有相信学挖坑的同学也都有一些这个OpenGL的经验啊，这里我们对这个语法不做细说啊，大家只要会C语言，其实看这个非常简单啊，首先我们还是写上版本号啊，四五零。
gsl四点五然后呢？
我们开启一个扩展extension。
glarb.se per哎separate shader来看一下separate shader OK，然后objects。
呃，enable这扩展开一下啊，这样的话就能够便于在vulkan里面做编译啊，然后layout location=0这个地方呢，我们写作out vector 3，然后呢，叫做out。
color okay，这个我们定义了一个输出的调啊，叫做color。
那么这一步呢，就是向fragment的段那边，它位置为零的地方去输出一个color啊vector 3的color。
OK，那么接下来啊，我们开始啊，我们开始去定义这个数据呃，我们都知道啊，就是在三角形在空间当中的一个三角形啊，经过MVP变化之后会被转化成一个什么就是一个ndc坐标系下的点，对吧？
nd坐标系下的点。
ndc是负一到一对吧？
会归发成负一到一，那么在这里呢，我们就不做MVP变化了，直接把这个顶点的数据写到隧道里写死啊，我们来打二。
position 3。
有三个屏幕上的点啊，就三个键MVP变化后的点啊OK，然后等于vector 2，然后呢，它是一个数组对吧？
这个数组呢，我们还要把它做一下初始化。
那么，数组的第一个元素是y二二，然后它的坐标x是零点零。
I坐标是负一点零，那么这个啊，一看就知道是不是沿着中轴线啊，沿着ndc的中轴线往下走啊，往往上走，然后走到一个单位上啊，走一个单位上这个样子。
因为在vector下的y轴是朝下的啊，所以负一是在我们视就是视线的上方啊，然后vector 2这边是个什么是零点五？
然后呢？
零点零这样一个点在哪呢？
在x的正方向啊，就是右边在x轴上，右边零点五的位置，然后呢？
最后一个是在x轴的左边零点五的位置就是负的。
OK，在我们定义完了这个vectorization，然后我们给每个点再定义一个什么定义一个color啊，color还是三个点？
等于vector 3。
然后是个数组。
然后vector 3摁到rtb啊，红色一点零一点零诶零，然后呢，第二个颜色是？
绿色一零第三个点呢是蓝色。
零一OK，这样颜色我们定义完了，然后呢，我们再去做一个men函数。
啊，做到这里呢，可能很多同学有疑惑啊，说你定这些数据干嘛的是吧？
我们在这边会做详细的讲解啊，不要不要着急啊，首先呢，是GL position这个变量呢，是gls gls l一个内置变量啊，这个内置变量的意思就是说啊，在这边做完MVP变化后的顶点的坐标。
屏放到这里面，这这个内置的变量会将这些值传到下面的阶段啊，比如说传入fragment这一阶段这个样子，然后vector four它是一个其次坐标啊，等于什么呢？
等于我们position。
那么okay，这里面叫positions啊，这个数组。
等于positions的第几个呢？
好，那么在这个地方我们就开始讲解了啊，大家不要啊，看到说这边定义了多数据啊，不知道到底这个fragment这个vertex现在在干什么？
进入到我的text时代后呢？
它首先啊，肯定要为每个顶点去升去走一遍，这个我的text时代，那么我们今接下来哈，我们后面啊，会给大家讲一个动作命令队列啊，命令队列也就是说呢，真正指使我肯去绘制的那个命令。
啊，其实是通过命令队列发出的，那么在那个命令队列里面的话，我们会写明白说，我现在想绘制的是一个三角形，它由三个点构成，那么这个系统就知道OK，当前我写的这个fragment的，这个vortex leader会被执行三次。
每个顶点一次，虽然我们并没有输入顶点距，但是我们告诉它了，我想执行三次，这个谁的？
而且这三个三个我text谁的执行完毕后的结果，我们能达到的这个GL position啊，这三个GL position应该构成一个三角形。
那么，对于当前啊，假设有某一个顶点啊，这三个当中某一个顶点，它执行了这个vertex谁的那么啊，它就会被它生成一个一个内置的变量，叫做GL vertex index。
会生成这么样，那这个变量是一个内置变量是干嘛的呢？
它代表了当前你要绘制的这n个点啊，要绘制的这n个点，它们啊，在输入到我text sheet阶段的时候，那么当前执行的这一个我text sheet它到底是哪一个点？
啊，再重复一遍，我们假设呢，有三个点，那么这三个点呢，会被并行执行，每一个都执行这个vortex阶段是并行的，那么对于vortex阶段，讲它会给每一个被执行的vortex段生成一个内置的index变量，代表了当前所执行的vortex share。
里面那个点的这个编号啊，编号OK，这边讲完了啊，我们接下来是不是通过这个就能索引到当前执行这个谁的点是哪个是吧？
可能擦也可能擦也可能擦对吧拿到。
好了之后呢，我们ctrl z啊，就给它设为零。
然后欧米伽一点零就好了，这样的话GL啊，这个position就输出了，输出之后我们还需要向下个阶段去输出什么这个out color是吧？
out color就简单了啊，等于colors了。
呃，color这边有colors。
对吧？
colors的第几个呢？
是不是还是这个对吧啊？
这个index好了，那么三个顶点每一个都经过了这样一个我的处理，那向后输出了三组数据啊，每一组数据都包含了当前屏幕当中ndc坐标。
以及当前这个点的color，随后这三个点三组数据啊，就会被进行差值和离散化，变成一个一个的小格，那么假设我变成了1000个啊，小图圆凑成了一个三角形是吧？
1000个小像素，那么这1000个小方格里面每一个都会有一个out color和一个。
position啊，所以说呢，接下来我们要开始写的是。
fragment啊，处理每一个fragment。
好，同样先把扩展拿过来。
好，然后layout location=0，我们location=0的地方输入的是一个颜色，对吧？
in color啊，刚才我们是out color按location为零的地方输出这个in color啊，向location 0的地方输入。
然后呢？
我们还想输出一个颜色，这个输出颜色就是当前这个图源，或者说当前这个像素所对应的图源啊，它的颜色是什么？
我们是vector four啊。
然后呢？
out color OK最后啊magnet four比较多的一个维度啊，这一个维度是什么？
是透明度阿尔法值啊，然后void name。
OK呃，这个地方我们直接输出就好了啊out car=vector four，那么这边是in color，然后呢一点零的阿尔法阵输出直接输出就好了OK，那么这个谁的呢？
是这样啊，我们刚才说了，前面那个vertex会被离散化掉，对吧？
变成一个一个小方格。
一个一个小像素，每个小像素里面呢，都含有当前输出这个数据的差值，对吧？
将输出这个数据的差值，这个差值呢，就是被每一格所接收，那进来的就是这个，那我这格呢？
丢到的数据直接就输，送出去就好了啊，直接输送出去。
那么，这个平常的这个小方格就会被点亮成这个颜色，对吧？
这个颜色好，那么接下来咱再创作一个东西啊，就是说还要再做一个诶，再做一个文件。
啊，这个文件呢？
叫做compile。
点bet啊，我们拿这个WINDOWS的命令行做一个bet。
OK，那么这个compile的过程什么样子呢？
compile的过程就是说呢，我们首先啊，看一下我们的。
啊，这条就写的稍微简单一点，不要写太麻烦了啊sorry party是吧？
这是我们的在病里面是有一个工具的啊，叫做glsl就这个东西，这个东西就是我们把glsl变成的这么个玩意儿啊，进去别把这命令拷过来。
然后这么一个操作。
gls gls l log.好，它的输入叫做什么叫做？
呃，在这。
好！
它的输入首先是我text c点啊，来xc点二，大家注意啊，你所有的我xc点啊都要写成这样一个点word的，这样一个格式啊，然后看o，然后就是说你输出一个这样的文件啊，我们叫做什么呢？
叫做VS点二啊sperm v啊。
然后同样这个命令从fragment切掉上读一遍。
fs啊lesson fragment跟这个sheet fact。
OK，走完之后我们就要把它POS住啊，再看一看输出POS住的话是能够看到输出的啊OK，那我们接下来左边看一看啊。
通过这个shift右键。
打开方向compile不行好，我们就看到啊VS sv和fs就输出了啊，我们把它出来。
嗯，在这个c mic下面啊VS会为我们生成一个运行时的环境啊，在out build叉六四下面啊，会有这个运行程序，这个运行程序呢，会链接啊，会从这儿链接各种各样的资源，或者读取一些文件啊，等等会这样，所以我们把这个shade放放在这儿啊shades。
把生成都放在这儿，这样方便我们接下来写程序的时候呢，直接就是向这个文件夹读取啊，因为编译好的程序会跑到这儿来，从这个环境下运行啊，那我们写的比如说读取当前文件夹下就这个东西的话啊，就就就会从这儿被触发执行是这样好。
那么，这节目到这里啊，就是主要带领大家去呃玩一玩这个，这斯巴威还有说写两个简单的十字儿，以供我们接下来使用。

