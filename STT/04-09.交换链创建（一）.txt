04-09.Vulkan-交换链创建（一）

我们这节课来完成的创建，在完成它的创建之前，我们先记录一些东西，首先我们所选择的。
我format啊vk的format表面格式。
format.然后我们还要记录v这个是它的大小。
accident.记录完这两个东西之后呢，我们来这边没有变蓝啊OK没有问题。
记录完这两个之后啊，我们还需要一个东西啊，那么我们在创建完之后，我们当然要为其创建什么呀？
创建图像对吧？
在的表达是这样的。
我们现在先用一下啊，图像呢，后面会专门去探讨啊叫做。
OK m stop chain images.然后呢？
我们接下来还要为这个创建它的管理器啊做。
vk image view.叫做msw。
chain image v is.那么进来的是这样。
OK，那么这样我们就齐全了啊，这个vk image view是干嘛用的啊？
这个是用来管理这个vk image用的，大家可以这么理解这玩意儿，就是一个白纸啊，它就是一个存存储的一个憨豆。
啊，它还不是图像啊，它还不是图像里面就相当于它不是有啊gpu内存的东西啊，它只是一个handle在CPU端的handle啊。
那么，真正杀的时候是由创建的啊，所以这个东西它是没有自我管理能力的啊，是需要用这个image view去管理这块东西所代表的gpu。
内存啊。
叫做vk image由。
呃swot chain创建。
那那么我们的销毁。
也要交给。
那这个的话就是啊，对图像的管理器啊，或者说管理框架。
OK，那么我们声明完这一辆之后啊，我们就要去到我们的里面啊，从这。
构造函数这儿开始对swot进行构造啊，第一步我们已经获取到了swot chain的那些支持的参数。
那么，我们接下来开始筛选，首先筛选啊，选择vk format。
OK，那么vk surface format？
然后k HR诶k HR。
at format.kh 2。
这没问题啊，那么等于swot chain呃surface format。
等于choose。
surface format.参数是一个这样一个数组啊swap chain。
support infer的诶。
这里support infer的。
formats啊，去选一下吧。
选择出来之后呢，我们再去选一下它的present mode啊选择。
present mode.那么是vk present node k HR？
present mode=choose present mode。
传入的另外一个数组啊stop chain。
infer的。
prank mouse.OK，现在我们两个东西都选着了啊，接下来我们还要选一个什么呀，是不是选择？
交换链范围是吧？
把它大小vk accident 2d。
那么accident=choose。
accident.呃，这个叫做capabilities啊sop chain。
infer的capabilities。
OK，我们看下这边儿。
嗯，又是枚举的问题啊，这个倒不是问题。
好，那么接下来我们要设置一下它缓冲的数量啊，就是我们呢，不是有一个队列吗？
对吧啊？
假设我们有三张图，我们就把第一张选好扔进去，然后选第二张啊，类似于这种东西。
我们现在要设置一下啊，现在要设置一下在sw ption当中，我们到底有多少幅图像啊？
叫做设置图，图像缓冲数量。
OK 32 t image count等于等于什么呢？
我们现在先让它等于啊。
里面的capabilities的叫做me an image count+1啊，我比你最小的image数量加上个一。
啊，然后接下来呢，我们要看一下啊，那个我们去怎么设置啊？
如果。
首先，第一个swap chain。
support infer的啊capabilities。
它下面的麦子，如果说它的最大的图像数量啊是大于了零，并且。
什么呢？
image count就这个东西，就我们刚才设置的这个。
啊，并且image count它是大于了。
我们的infer的capabilities的呃。
这个max image count。
啊，这个地方啊，说什么意思呢？
就是说啊，如果我们现在的这个。
交换链有最大的图像的限制，并且这个数还真实的存在是吧？
大于零真实存在。
然后我们这个图像的设定的数量呢，又大于了它的最大要求啊，最大限制，那么我们也只能够把它怎么样，就是设置成人家要求的样子啊，等于。
stop chat.infer的capabilities的max image count。
啊，那么在这边的话呢，需要注意一点啊，很好玩的一点在于哪呢？
在这啊，如果这个max image count。
为零，那说明什么呢？
说明只要内存不爆炸是吧？
我们就可以设定人数量的啊，这个images啊times。
OK，那么我们找到这个东西之后呢？
接下来我们就要开始真正创交换链了啊，大家知道在当中创建东西的话呢，一定要先怎么填写信息是吧？
填写创建信息啊，这个大家都很熟了。
呃，叫做infer cation OK，叫做create infer等于这个。
这个地方必须要置空，各位啊，要注意给大家写一下注释，此处初始化必须置空。
啊，滞空。
诶，滞空。
为什么呢？
因为。
啊，会有未忘啊，会有忘记设置的量。
值为随机对吧？
就比如说我现在做这么一个题，要不给它制空的情况下啊，那么我设置了，可能人家有六个参数，我只设置了三个参数，对吧？
那么另外三个参数就随机掉了啊，就很奇怪会出现结果会出错。
啊好，我们看填写great infer又是create infer是吧s type？
那么，等于vk structural？
retype.哎，你看我从不下啊vk啊，structure ure哦type。
swap chain create infer.HR好，然后接下来create infer的surface啊，我们要兼容哪个surface呢？
兼容这个surface啊m surface的。
get surface.OK，然后create infer它的。
me an image count.啊，等于了我们的image count，那什么意思呢？
就是说啊，这个地方比较有意思啊，就是说。
我现在设置的数量。
啊，那么是适适合于当适合当。
前情况啊。
可以适合当前情况啊，但是可能会得到更多，对吧？
这个意思啊，我给他这个数量，我是说最小的就是这个数量了啊，你能弄给我弄多几张就弄多几张，这个意思啊，然后create infer。
的image format。
就是我们的表面格式等于什么呢？
等于我们的surface。
fermat.a等于我们surface format的format。
OK，然后create infer。
的color space=surface format的color space，OK？
然后我们还要create infer。
accident等于我们的accident。
好，那么接下来的话是图像层次。
的呃叫image ary啊layers，我们就写个一就好了，这个地方比较有意思啊，大家如果是做个vr的开发的话啊，我们vr渲染啊，一般都是要进行一个左右分屏，对吧？
左右分屏，而且是它俩是渲染是同步的啊，为什么会有左右分屏呢？
你左边这只眼睛看出去的角度和右边这只眼睛看出去的角度是不一样的，这样会产生卫生感啊，产生深度感。
对吧，那么这里啊，就是说我们可以写一下啊呃，图像包含的层次。
啊vr 1般会有两个啊。
OK，那么继续create诶，create infer。
那么这边有一个叫做image，就是说呢，我们做这个交换链啊，它不是要做图像嘛，对不对这边啊？
交换链生成的图像到底用于何处？
用来干嘛的啊？
它的作用是什么？
我们告诉它作用是vk image，然后usage color attachment bit。
啊，学过OpenGL的同学应该知道啊，不是我们OpenGL里面经常会有一个attachment的概念，对吧？
那没学过的同学呢？
我给大家讲一下啊。
呃，所谓attachment是指什么呢？
我们当前啊，渲染在这个窗口上为一帧对吧？
一帧一帧的渲染那么一帧呢？
称为一个frame啊，就是一个frame。
这么一个frame里面呢？
它包含的那个可以用来画画的那个那张图，我们就称为一个attachment。
那么，这种color attachment就是说我这张图是用来上面画颜色的，那有同学问有没有啊？
既然是图的话，那肯定是画颜色对吧？
不一定啊，不一定在一个frame就是一帧里面啊，含有的用来画深度啊，用来画深度信息。
OK，这个后面会讲到。
那么我们这里做完了，做完之后呢？
我们还要去啊，做它的队列组的设置啊，队列组的设置这边我们。
来写出来啊，再给大家去讲。
那么这样，如果哎，这个队列组我们好像还获取不到啊，那这边的话先给大家写一下吧，就告诉大家这是干嘛的啊？
因为图像啊，就是交换链。
的图像会被用来渲染或者干嘛呢？
显示对不对？
而啊，渲染跟显示分别于啊，分别作用就是分别使用不同的。
对列对吧？
它分别使用不同的队列，我们知道啊，渲染命令提交到渲染队列是吧？
显示命令提交到显示队列啊？
所以会出两个队列，使用同一个啊交换链的情况。
啊，那么我们就需要设置让交换链的图像被什么呢被？
两个队列啊。
对列使用兼容啊okay这么个意思。
那么，我们关于队列组啊，之前是在写在这个啊里面的啊，我们里面已经存下来了，这个这个family啊，两个family已经存下来了。
我们现在需要把它给get出来啊，再写get函数。
auto get呃，比如说我们get graphic。
q.family.const return m graphic q family啊。
好，那么接下来我们no discard。
诶。
auto get呃present q。
三，魅魅力。
const return and present.用的q。
family.OK啊，这样的话呢，我们就能获取到两个q分贝类了啊，我们看它们是不是属于同一个类型啊，在这里我们判断一下。
啊，如果。
我们device。
get graphics family啊q family。
等于了m device。
get present.kill family啊哎，如果它俩相等的情况下啊。
那么是一种情况else，它俩不相等，又是另外一种情况啊，我们先看相等的情况，相等的情况，这俩队列组都是一样的，对吧？
一模一样的两个队列组。
那无所谓了是吧？
那我可以不设置这个东西啊？
create infer the image sharing mode啊？
就是说呢，它的一个分享模式。
啊，如果你它俩队列都一样的情况下，那我们就用这个模式叫做sharing。
mode.呃，叫做xc class ive exclusive啊，这个东西就是说专有模式啊。
被独占。
被某一个队列组独占。
啊，性能会更好，对吧？
不用兼容了。
然后呢？
create infer呃。
那么OK，这就不用再设置了，因为我们上来已经把它置零了啊，剩下的参数都不是零啊，因为我们一开始把它置零了。
在这边的情况下，如果两个队列完全不一样啊，显示归显示是吧？
渲染归渲染，那我就得注意了啊。
首先，它的image mode，sharing mode=vk sharing。
mode叫做CON呃，叫做concurrent啊，就是说这里可以被啊。
诶，可以被共享的模式啊，性能肯定不如上面的好，对吧？
那么，它的q family啊？
q family index count这个地方就得把两个队列设置进去了啊，在这里我们把它先拿出来做成一个vector啊。
呃，传回的应该叫做Vicky gill family。
诶，它变量名叫什么名字来着？
叫v kq family啊，是一个int啊int 32。
随便搞错这一个I int。
圈儿，那么叫做q。
叫做family。
等于。
等于什么呢？
等于那个这样。
把他俩搞进来。
一个这个一个这个OK。
然后我们把这个q family s给它设置进去啊q family s index count等于什么呢？
等于static。
cast啊int 32杠七。
然后。
这边是一个kill family s的size。
OK，接下来的话create。
infer告诉他被哪两个q给共享了啊？
indices=q family s。
诶的data好。
那设置完这个东西之后，我们还有一堆东西需要设置啊。
接下来，我们要设置啊，它的初始变化啊，交换链的图像初始变化。
指变化，比如是否需要反转或者对称啊，这种东西，然后。
那么，transform诶，create infer啊infer。
然后transform。
那么，它的transform我们等于什么呢啊？
直接让它等于我们当前这个。
它的。
啊capabilities。
的这个current transform啊，就是默认的这个啊，我不管你反不反转，或者干嘛就给它默认的？
然后呢？
接下来。
我们还要设置一个create infer的，叫做composite阿尔法。
等于vk。
composite.阿尔法。
啊，这个句话什么意思啊？
其实非常简单啊，就是不与。
不与原来哎，与原来窗体当中的内容混合啊。
因为我们3d渲染出来的这个surface啊，是贴在我们的窗口上面对吧？
如果现在这个窗口里面已经绘制了一些东西了啊，就是用别的东西，比如说GUI啊啥的。
然后我们再去贴上这个三的东西啊，假设我们这整张图片都有一个阿尔法透明度啊，它的意思是说你要不要与我这张图像下面的就是窗口原来的东西混合啊，我的意思是说不混合啊，不混合我们是一个。
我是一个实体啊，不与它混合okay？
那么，接下来啊，create info很重磅的东西是不是啊？
叫做present mode等于我们的present mode啊？
选出来，然后然infer，然后它的clipped=vk two，这是什么意思呢？
就是说啊。
当前，窗体被挡住的部分不用绘制啊，什么意思呢？
比如说我们当前这个窗体啊，然后我们。
啊又又拿了一个什么东西啊，比如说又拿了这么一个东西，对吧？
把它挡住了啊，把这个挡住了。
那挡住之后呢？
挡住的东西我们不会治啊，就这么一个死啊，这部分不会治，但是啊，大家要注意一点啊，但是会影响到啊。
回读这个很重要啊，你把当前渲染的东西回读成一张图片，或者是说保存成一个电影的时候，对吧？
保存成一个视频的时候就。
就会出问题了啊，因为这一部分被导有绘制，对吧好？
那么接下来啊，我们要开始。
去用这些东西了啊。
fv k creates w chain.k HR.OK，然后呢？
传进去什么呢？
首先是device device。
get device.之后的话呢，是它的infer啊，create infer。
然后呢？
是分配器，然后ptr。
然后呢，最后是我们要创建的sop chain，对吧？
MS wop chain。
如果它不等于vk true。
那么我们就要开始报错啊throw。
h row.throw一个s td run time error。
field two create啊，sw chain。
好，那么到这就结束了啊，但是我们还要去做什么呢？
这几个图片对吧？
这个图片呀，还包括啥的啊？
这边我们回头再讲啊，回头再讲。
然后这边的话呢，最后还有一个东西啊，我们来把这个m sub chained format=surface。
format.的format。
m sop chen.accident等于我们的accident。
好，那就OK了。
那么，我们运行一下。
嗯，有错误吗？
这里好OK，我们这边原来用的是option啊，所以这边应该是value。
这边应该是。
y6它有对比的时候呢，我们啊应该也可以用y6。
好，我们看一下。
哎，有错误。
看看什么错误啊？
OK好，这是我们刚才跳过去那个步骤的问题啊，这边。
这边应该用create infer的啊，我们还是叫做q family index count，我们是叫做把它制成零吧。
告诉它没有啊，告诉它没有，然后呢create inferred q indices=1个null呃掉。
这样的话才可以啊，刚才内存里面，你看这个地方没有读出来啊，没有读出来好，那么我们再跑一跑。
看还有什么问题？
啊，又出现了一个异常啊，又出现了一个异常，看一下刚才查了一下啊，是一个非常愚蠢的错误，这边啊应该是vk success。
刚才我们是vk two，对吧？
触啊，就会导致。
它直接弹出了啊。
就错了啊，这样的话呢，就会完全弹出啊，这边应该是vk。
success好啊，这是一个很常规的问题啊，这个地方大家也要注意啊，这个东西啊API实在太长了啊，东西实在太多了。
所以这个地方很容易犯错，大家也要在平时注意一下啊，现在应该就没有问题了。
好关掉窗口看一下反馈啊，并没有弹出的validation layer的错误OK？
那么，这节课就到这里啊，我们接下来要开始思考一下啊，怎么去给它分配图像了？

