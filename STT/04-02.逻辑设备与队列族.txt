04-02.Vulkan-逻辑设备与队列族

我们这节课呢，先对原来的代码做一次检查啊，因为我们毕竟是包装了一个比较薄的wrapper层啊，那么这个wrapper层呢，里面会有很多的细节问题啊，尤其是初始化跟状态啊，我们由外到里来检查一下。
去到application点h啊，这边同学们也要自己检查一下代码，这些都需要进行初始化啊，尤其是智能指针对吧，哎，智能指针都要变成null ptr的初始量，然后呢gfw对吧，它是一个空值。
随后呢，我们再进到instance点h啊，这里面呢，也需要vulkan的量都被初始化为v know handle啊。
vulkan的量初始化为这样子好，那么我们还要检查一下啊。
instance点APP这边啊，之前没有写，现在呢，给大家补上，大家也要注意这个位置啊。
if enable validation layer的情况下，才会对这个messenger进行一次吸垢啊，进行一次毁灭OK，然后呢，这道device点h我们再检查一下，这里面啊instance的这个实例也必须是now pdr。
然后physical device是吧？
marken的变量一定是v key now hand OK，那么接下来呢，大家也要啊，自己去检查一下自己的码啊。
好，那么接下来我们来讲一讲啊，命令队列也就是我们这节课的主题。
什么是命令队列呢？
它到底在哪个环节呢啊？
大家看是在这个环节啊，是执行这个东西的，那么每一个device它的里面呢？
其实都包含了它所支持的这样一种队列行为。
我们现在在这个逻辑图上展示的呢，只是一个渲染的任务队列啊，真正的任务队列啊，分为很多种类型，我们看一下队列呢，由于它产生了分类啊，所以说我们提出了一个叫队列族的概念在v里面。
那么队列组啊，是一个队列的类型，与C加加当中的class对吧？
它只代表一种类型啊，不代表具体的某一个列，那其中规定了本类型队列应该满足的队列功能。
举个例子，比如渲染队列graphics q，那么我们绑定管线啊，绑定这个rand pass呀，然后执行报告啊等等啊，这些跟渲染相关的命令就可以送到渲染队列里面执行。
那么，渲染队列就被归为了一类啊？
归为了一个队列组对吧？
就是graphics give。
那么，还有叫做preview啊，显示队列，当你这个图片渲染完毕之后一帧对吧？
你把它送到屏幕上去显示，那么这个显示的命令呢？
就会被送到拥有这个显示功能的队列里面啊，就是。
present q对吧？
显示队列。
接下来是传输队列，就比如啊，八份之间的数据拷贝啊呃，你读入一张图片，将把它拷到gpu当中的缓存啊，那么这样一个拷贝动动作啊，就是一种传输。
再比如说CPU与gpu之间的一个数据拷贝，包括回读啊，你渲染了一帧图片，你想把它从gpu当中哎，再读回到内存里面，保存成为一帧或者保存成为一个视频。
这样的话呢，就是要用到渲染的这这个传输队列啊，传输队列那么很多种情况下啊，我们申请一个队列，或者是说我们去查找显卡当中的某一个队列读的属性啊，那么渲染队列啊，跟传输队列极有可能它们两个是一个类型。
也就是说，一个队列组拥有渲染跟传输两个功能啊，也可能当然我们也可以专门为传输做一个队列啊，也是可以做到的。
好，那么我们看一下啊，命令队列，它是由命令队列组为类型而创建的，一个队列的实例驱动呢，只允许一个队列组啊，创建较少量的队列啊，一般情况下呢，我们写哪个类型，比如graphics。
和present q我们各自创建一个队列就行了啊，所以呢，可以使用多个二级的命令提交到一个主命令当中，也就是说我们之前给大家讲的那个渲染图谱啊，大家看一下。
我们就可以多个二级的指令，对吧？
装到一个primary command打粉，然后提交到渲染队列里面啊，这样的话，我们只需要一个队列就好了，对吧？
但是却装很多个命令啊，很多个物体的渲染命令。
OK，那么其实这个就是什么？
这个就是多线程渲染的秘籍啊，就是多线程渲染的方式，这个意思。
然后呢，创建队列需要与逻辑设备挂钩，先创建逻辑设备，再由设逻辑设备啊对齐进行个创建，这样子好。
那我们现在回到代码啊，这边呢，我们拷贝了一份工程出来啊，叫做lesson device啊，这是一个专门讲device的，这么一个工程，然后呢，在device点h里面，我们现在可以添加相关的东西了啊，首先。
optional诶，这里是没有的吗？
我们看一下optional在这填一下。
optional okay，optional呢？
你应该是要规定它这里啊，四加加17啊，这里用了一个optional。
ops呢？
是干嘛的呢？
一会我们就能看到了啊。
optional然后呢，是an int 32类型，7 optional有两个状态啊，第一个是它有值的状态啊has value，第二种是它没有值的状态啊，那么这个optional呢，我们用它来存储什么呢？
我们这节课呀，就是主要聚焦在这个graphics kill family上面啊。
我们用它来存储。
存储当前渲染任务队列组的啊的ID。
当前，渲染任务对立足的ID啊，大家一定要看清楚啊，是对立足而不是对列啊，叫做graphic。
pu哎。
family OK，它不需要初始化啊，它本身就会被初始化成一个无知的状态啊OK，那么这就是graphics kill family，然后呢，我们啊，再为其生成一个什么vk q。
叫做graphics q。
然后初始化week now。
看到好，这样我们存的这个队列组啊，也存了这个列，然后呢，我们再写一个是叫做。
啊，逻辑设备啊，我们还要生成一个逻辑设备才能去生成这个q是吧？
像vk device。
m device.wait now.handle好，这样我们的准备工作啊，就可以就去了啊，做好这个准备工作之后呢，我们要添加两个函数啊，第一个函数呢是寻找这个q families啊，寻找q families。
就比如说呢，我们可以这么写啊word find啊，应该说innate吧innate q family sies。
啊，这样vk cz call device。
我们传入一个物理设备，从这个物理设备上呢？
我要找到啊，为我们接下来的这个qu family啊，给做初始化是这个意思啊，在里面找一找，看还有没有我需要的队列组，需要的话呢，就给它赋上值。
是这么一个用处来，我们先把它进行一个实现啊。
这里void叫做呃device呃对。
in it,cube families AK physical device.OK，然后呢？
这一步应该是放在哪里啊？
这一步是不是应该放在这个呃，它生成完毕之后对吧？
在这边它生成这个。
pic device之后啊，就去要去生成它了，in ni tq miss啊，就要生成它了。
然后需要传入的是m physical device啊，这个device已经有了对吧好？
然后。
诶，这里呢，我们首先还是老套路，是不是要获取所有的设备队列啊？
获取所有的设备队列int 32t，然后呢q family啊，就叫这样吧q count。
啊，等于零，然后呢啊，当然是做watson式化，建议大家还是把这个名字写全啊啊，我写全一点吧，因为写全呢，对于程序来说，阅读性比较好啊q。
family count啊，就是有多少种不同的，这个什么pu family啊，就是队列组，然后呢，用vk get。
physical az call呃q aqu UE family。
没有出来啊q device。
q family类。
properties哇，真的是一个API名字，好长诶，这边加上这个应该是不对的，是vk get physical device q family properties啊，这个函数。
传入什么呢？
第一个传入一个physical device就是这个device，然后第二个是count啊q family count老套路老套路啊，然后now掉是吧？
没有什么内容，因为我还没有给它分配空间，那接下来呢？
分配空间啊看。
其实在这个vulkan里面啊，写着写着就发现啊，其实都差不多是吧，这个各种各样的获取，各种各样的呃，这个分类啊，根据它的各种性质有挑选去，其实vulkan最麻烦的地方就是前期这些东西啊。
啊q family类啊，叫做q family类似对吧？
就是说把它所有的队列都挑出来啊，队列组，然后它有多少个空间呢？
q family count。
好，然后拿到这个，看到之后我们再一次获取。
这样这样更式好看一点。
family s对吧？
好，这样我们就获取了所有的对列组，然后我们在里面啊，去找到一个graphics q啊，先写一个ID啊，这个是用来做ID的，然后for。
to nst auto.QQ family.q family 4。
便利所有的啊，这个队列组找到其中的每一个队列组要看一下，如果q family它的什么q就是说每一个队列组它都支持啊，去生成一些它这个组类的队列对吧？
你能支持生成多少个你别？
生成是零个对吧？
能够生成的，那就不行啊，所以说它能够支持生成多少个对列的实例啊，要比较大于零，并且呢？
q family.啊，它的q flex q flex是什么呀？
其实啊，一堆未操作啊，大家可以理解为一堆未操作，我们先看一下。
然后看q families是v kq flex啊，v kq flex的话呢？
呃vk flex是一个32位的整数啊，32位的整数啊，也就是说呢，它可以用来做微运算啊，它的32位里面每一位代表一个特性啊，这个意思。
然后它与上一个v kq graphics beat啊，就是说你这个你跟我这个graphics beat做个语操作啊，做个语操作，那如果说是它是OK的，没有问题的话呢，我们加括号吧。
如果谁对面找一个炮吧。
如果是没有问题的话呢，说明什么？
说明你是拥有这个特性的啊，你的q FAX里面是有这个q graphics的，也就是说你是一个什么包含有渲染任务，队列功能的队列组啊OK，那么如果你是这个队列组，那么我的是不是graphics？
q family是吧？
它就能够等于当前这个I了啊，等于当前这个I，那么如果发现不行的情况下啊，那么是是不是我要定义下一个对吧？
就加加I对吧，所以这个I是用来记述这个q family啊，它的一个index。
那么呃，这个q family在系统当中啊，它的这个排布啊，它的排布零一二这样的编号啊，跟我们外面这个是一样的啊，也就是说呢呃，它从这个函数里面把这个对列组的信息拷贝到这个东西里面的时候啊，是按照它的ID顺序拷进来的。
而ID顺序是零到n啊，是这个意思，所以说外面可以用它来表示这个队列组的ID。
那我们检查一下，如果m graphics q family啊，它has。
六啊，就是它有值对吧？
那么六八它给break啊，为什么呢？
就已经找到了啊，这个具有图形功能的q family了，都不需要再去再去寻找了就OK了。
好，然后最终呢，我们在这边啊啊，也不用忍这儿了OK，这样的话，这个函数就完成了啊，就完成了。
okay,device.那么，我们先测试一下这个函数啊。
OK，看一下。
哎，没问题了，怎么可以？
删掉的时候又出现问题了好。
我们来看一下，删掉的时候出现什么问题了，刚才。
本来这些链并没有给出什么问题啊，看就是一个C加加本身的问题，我们看一看。
我们走到这一步。
好走。
OK呃，这个问题呢？
是这样的，就是看来这个VS对于cm ake啊，支持性可能没有这么好啊呃，我们把这里啊全部清理一下啊，全部清理一下，然后再做编译。
呃，这样的话呢？
这个过程呃，好像就不会出错了，是这样子，那它为什么呢？
可能是就是它原来编译的这个范围啊，就是说没有把我的头文件上面做的更改，就是我们刚才加了这么多的更改给编译进去啊，然后呢，可能就是之前的obj或者是之前的什么样的文件的问题。
那么，我们全部清理一遍之后，统一啊，改编成咱们变成咱们这样最新的套餐码，这样应该问题就不大了，是这样的，然后具体的逻辑错误呢，确实没有啊，那么同学们在自己写的话呢，可以选择性的啊，使用si my nc list或者是说用呃cline啊，就这个名字。
cli on啊，用这个intelligence idea这个公司啊，intelligence这个公司做的这个cline这个编辑器啊，会更加的就是兼容这个c make list啊，会而且会做全局的这样一个动态的检查。
OK，那么我们现在啊，已经生成了q families，对吧？
我们接下来呢，要为它来创建队列，并且我们要创建自己的逻辑的device啊void。
great logical device.好，我们去到这里加一个函数啊point device，create logical device。
好，那么大家还记得啊，逻辑设备是什么？
逻辑设备就是这个物理设备在客户端的这么一个句柄啊，这么一个句柄，然后呢，在这边。
我们创建任何的open对象，要做的第一件事儿是什么？
填写创建信息对吧？
那么填写创建信息的话呢？
我们要填写两份，第一份是给到队列创建的信息。
q great，等一会儿。
叫做q create infer。
till create infer啊。
对吧，必须要把type字段先写出来。
vk structure ure，然后type啊device device q。
create infer.OK，然后是q create infer的呃q family index啊，就是说呢，我们当前要创建的这个q啊啊，就是当前要创建的这个q，它的什么family index是什么啊？
family index。
那么就是我们当前的这个m graphic。
q family的value。
啊，它的值，然后呢q create infer啊，它的q count我要创建多少个队列呢？
一个队列啊，一个队列，然后呢，接下来要给它创建呃，赋予它的什么优先级float。
叫做prayer哎priority=1点零啊，这个优先级呢，就是说呢，它是一个从零到一的，这么一个float数字，那么对于这个float数字来讲的话呢呃，如果你越高，那么你的执行先级就越高，说实话，如果说你把一个队列它的，比如说两个队列啊，一起去提交上任务。
命令了啊，那么有可能优先级高的队列都执行完好几遍了啊，这个优先级低的队列还没有被执行过，也有可能会较为穿插的执行啊，这个是非常不确定的事情啊。
好，那么接下来啊q create。
一把priority。
取个地址q。
private那么接下来呢？
我们啊要开始。
填写啊叫逻诶逻辑设备创建信息。
okay，首先。
呃Vicky physical到device features啊，我们先做一个数据结构啊device feature。
那么，这个我们后面就可以填写很多的内容啊，就是说它所想要开启的这么一个逻辑设备的特性，比如说标像一星啊等等啊，现在还不需要开，先放在这儿，然后呢vk dy s。
create infer.device create infer.好开始填写它第一个肯定是什么s type是吧vk structure type嗯，叫做device great infer。
然后呢，它的pq create in fos就是刚才啊，我们填写的那个q create info。
好给它，然后它的。
q create infer的count啊，就是说我要创建有多少个这种create infer啊，我们可以做很多种这种create infer啊，创建很多种不同的队列等等啊，然后它等于一我说明一个啊。
然后他的。
p enable features等于。
device诶features。
大家注意，这边都是取地址啊，都是取地址，所以说啊，在封装的时候一定要注意一点啊，这个取地址啊，很关键，很多同学啊，就是说它延迟构建这个device，也就是说它填完这个device infer之后，把它存在的类里面并没有去即时构建啊，延迟的构建。
这也是一种方法啊，但是呢，你别忘了这家伙啊，如果说你是函数当中的一个这么像我这样一个写法的话啊，你这个device infer 1旦出了作用域之后，这家伙就没了，对吧？
这家伙就没了，然后你却取的是这家伙的地址啊，这个地方就容易出错啊，所以给大家做一下提示啊。
好enable features完事啊，然后是enable extension count，我们先写成零吧，就把它扩展好，把这块都弄完之后，我们还要给它加一个什么？
就是layer层啊，它使用跟我们呃，跟我们这个insights相同的layer层就可以了啊呃，那么如果诶在这里呢，我需要得到这个layer层的名字啊，所以说我把这个layer层提高一下吧。
原来它的这个velocity layer是在这儿的啊，我们现在把它放到。
base里面提高各个文件都可以使用它。
这边那么如果min stance。
那么这边我们要判断它是否开启了y的列啊，所以这个地方也还有一个判断函数啊。
叫做布尔get enable validation layer啊，我们在这个insensitively里面加一个函数啊，能get到啊return m enable validation layer。
好，然后这边儿呢，仍然是nods是吧？
必须要对它进行处理才行啊嗯，回到这儿re sentence get。
get以六为列啊，如果能开启外列列列的话，我们才去给它做这样的事啊，那么create device，create infer。
它的enable layer count啊，就等于了static past。
按enter 32杠七。
这里面是什么呢？
是不是validation layers的size啊？
我们刚才提高到这个base里面的那个啊const变量啊，就里面装了我们是列尔的名字。
device create infer the b呃叫做。
pp enable啊，layer names=validation layers的data好，这样的话呢else如果我没有开启，那么我把它封锁一下对吧？
让它。
直接干成零。
好，做完这一系列准备工作，我们就要开始了，如果vk create device啊。
那么常用什么呀？
应该是physical device啊，第一个参数，第二个参数是它的创建的infer啊device，create infer举例子啊，第三个是它的内存分辨器默认的。
第四个那么是device变量啊，我们之前写的那个逻辑变量m device。
它不如果不等于vk success的话，那么就出问题了，对不对？
所以我们就slow诶scd runtime error。
error field to create logical device.好logical device创建完毕了，我们要从它这个logical device这家伙里面去把队列创建出来啊。
vk get device q。
那么，第一个参数im device，第二个参数q family的index了graphic。
q的value。
第三个啊诶，第二个是。
graphic对，然后q index啊零，然后是qm q诶m graphics q。
啊，看一下这边出了什么问题啊，表达式必须包含类型OK，这边应该是family啊，好看一下，这就是几个啊，几个参数？
OK，这边的话，我们就已经拿到了这个device q啊，拿到了device q，那么接下来提交命令，我们就可以向这个graphic q里面去提交命令了啊，它被创建出来了，好，那么我们看啊，chronological device这个东西应该被谁调用呢？
是不是在？
innate qo finds之后，我们要调great logical device啊，logical device。
OK那么首先啊，这次我们学会了要清理对吧？
清理然后构建。
好，构建完毕，然后关掉，哎嘿嘿，但是在关闭的时候出现问题了，对不对？
横道线，它说什么艾维雷迪什尼尔告诉我们什么？
它说呀，这个这个玩意device是吧？
这家伙has not been destroyed哎，这个问题对不对？
也就是说呀，这个device这个东西啊，它应该是被destroy掉的。
啊，就是我们刚才创建的这个这里啊，我们刚才创建的这个逻辑设备是应该被提前销毁的，你不能在instance后面再去让它自然而然的或者悬垂在那啊，或者是说比instance还要晚去销毁，这是不行的啊。
所以说在这边device这边啊，我们在这个之前我们要加一个叫做vk destroy啊，叫做device destroy device。
它需要传入的是啊，一个device m device。
然后呢？
分配器呐？
清理一下，然后检查一下啊，没问题好。
好关掉哎，这样的话呢，这样啊，就可以了是吧？
unloading unloading啊，各种unloading就好了OK？
那么关于逻辑设备和队列啊，咱们就讲到这里。

